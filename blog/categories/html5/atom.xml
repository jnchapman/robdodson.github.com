<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: HTML5 | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/html5/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2014-08-06T13:24:52-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[@font-face doesn't work in the Shadow DOM]]></title>
    <link href="http://robdodson.me/blog/2013/11/19/at-font-face-doesnt-work-in-shadow-dom/"/>
    <updated>2013-11-19T09:27:00-08:00</updated>
    <id>http://robdodson.me/blog/2013/11/19/at-font-face-doesnt-work-in-shadow-dom</id>
    <content type="html"><![CDATA[<p>I was building custom elements with Polymer the other day, and I thought it would be cool to include Font Awesome for some sweet icon goodness. Everything was going great, until I switched over to Canary to check my work.</p>

<!-- more -->


<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/polymer-fonts-busted.png" title="'Busted Polymer Fonts'" ></p>

<p>uh oh...</p>

<p>At first, I was pretty confused. Why was everything working fine in Chrome, but acting crazy in Canary? I did some digging and manged to turn up <a href="https://groups.google.com/d/msg/polymer-dev/UUwew3x82EU/m9x2qWPi9ZoJ">this thread</a> on the Polymer mailing list.</p>

<h2>The Fix</h2>

<p>I had a bit of an "aha moment" when I remembered that the current version of Chrome doesn't actually hide any styles in the Shadow DOM, so my <code>@font-face</code> rules were ending up in the global scope. Canary, on the other hand, is encapsulating those styles in a shadow boundary and falling prey to an apparent bug.</p>

<p>A simple workaround is to pull your <code>@font-face</code> rules out of the stylesheet for your element, and move them to the top of your import, like so:</p>

<p>```
&lt;style&gt;
  @font-face {</p>

<pre><code>font-family: 'FontAwesome';
src: url('../fonts/fontawesome-webfont.eot?v=4.0.3');
src: url('../fonts/fontawesome-webfont.eot?#iefix&amp;v=4.0.3') format('embedded-opentype'), url('../fonts/fontawesome-webfont.woff?v=4.0.3') format('woff'), url('../fonts/fontawesome-webfont.ttf?v=4.0.3') format('truetype'), url('../fonts/fontawesome-webfont.svg?v=4.0.3#fontawesomeregular') format('svg');
font-weight: normal;
font-style: normal;
</code></pre>

<p>  }
&lt;/style&gt;</p>

<p><polymer-element name="semantic-ui-icon" noscript>
  <template></p>

<pre><code>&lt;link rel="stylesheet" href="./icon.css"&gt;
&lt;content&gt;&lt;/content&gt;
</code></pre>

<p>  </template>
</polymer-element>
```</p>

<p>I found this approach <a href="http://www.polymer-project.org/docs/polymer/styling.html#making-styles-global">in the Polymer documentation</a>, so I'm hoping it's considered a best practice. You'll also need to do this if you're using <code>@-webkit-keyframes</code> rules.</p>

<p>I hope that clears things up for some of you who may have been stuck. I know it took me a couple days to come up with this solution, so I thought it best to go ahead and post about it :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Repeating Templates in Polymer]]></title>
    <link href="http://robdodson.me/blog/2013/11/12/repeating-templates-in-polymer/"/>
    <updated>2013-11-12T15:14:00-08:00</updated>
    <id>http://robdodson.me/blog/2013/11/12/repeating-templates-in-polymer</id>
    <content type="html"><![CDATA[<p>I ran into a little issue this afternoon working with templates in Polymer and I wanted to quickly jot down my thoughts in case others bump up against this.</p>

<!-- more -->


<h2>Bindings</h2>

<p>Bindings allow you to easily pipe some data into your markup from a JavaScript object of some kind. If you've worked with a library like Mustache or Handlebars before then they should feel familiar.</p>

<p>In Polymer land, the <code>&lt;template&gt;</code> tag has been extended so it supports a few handy binding attributes. These include <code>bind</code>, <code>repeat</code>, <code>if</code>, and <code>ref</code>.</p>

<h2>How Not to Do It</h2>

<p>If you take a look at the Polymer docs on <a href="http://www.polymer-project.org/platform/template.html">template bindings</a> you'll notice that the binding attribute (<code>bind</code>, <code>repeat</code>, etc.) is always located on the first template. For instance:</p>

<p><code>
&lt;template repeat="&amp;#123;{ collection }}"&gt;
  Creates an instance with  for every element in the array collection.
&lt;/template&gt;
</code></p>

<p>This lead me to believe that I should write my element like this:</p>

<p>```
<polymer-element name="polymer-letters">
  <template repeat="&#123;{ letter in letters }}"></p>

<pre><code>&amp;#123;{ letter }}
</code></pre>

<p>  </template>
  <script></p>

<pre><code>Polymer('polymer-letters', {
  letters: ['a', 'b', 'c']
});
</code></pre>

<p>  </script>
</polymer-element>
```</p>

<p>But unfortunately that does not work <span style="color: grey;">#sadtrombone.</span></p>

<h2>The Right Way</h2>

<p>Polymer uses the first <code>template</code> element to create Shadow DOM, so if you want to use a binding <strong>you'll need to nest it <em>inside</em> another template.</strong></p>

<p>Our updated example would look like this:</p>

<p>```
<polymer-element name="polymer-letters">
  <template></p>

<pre><code>&lt;template repeat="&amp;#123;{ letter in letters }}"&gt;
  &amp;#123;{ letter }}
&lt;/template&gt;
</code></pre>

<p>  </template>
  <script></p>

<pre><code>Polymer('polymer-letters', {
  letters: ['a', 'b', 'c']
});
</code></pre>

<p>  </script>
</polymer-element>
```</p>

<p>And here it is running on CodePen:</p>

<p data-height="268" data-theme-id="0" data-slug-hash="wxrqf" data-user="robdodson" data-default-tab="html" class='codepen'>See the Pen <a href='http://codepen.io/robdodson/pen/wxrqf'>Polymer Template Bindings</a> by Rob Dodson (<a href='http://codepen.io/robdodson'>@robdodson</a>) on <a href='http://codepen.io'>CodePen</a></p>


<script async src="http://robdodson.me//codepen.io/assets/embed/ei.js"></script>


<p>I mentioned this to Eric Bidelman and he opened <a href="https://github.com/Polymer/docs/issues/191">a ticket to improve the docs</a>, so keep an eye out for that. Hope this helps some of you that may have been stuck :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shadow DOM: JavaScript]]></title>
    <link href="http://robdodson.me/blog/2013/09/02/shadow-dom-javascript/"/>
    <updated>2013-09-02T20:46:00-07:00</updated>
    <id>http://robdodson.me/blog/2013/09/02/shadow-dom-javascript</id>
    <content type="html"><![CDATA[<p>We're getting to a point where we've covered most of what there is to know about <a href="/blog/2013/03/16/html5-template-tag-introduction/">templates</a>, <a href="/blog/2013/08/20/exploring-html-imports/">imports</a> and shadow DOM (<a href="/blog/2013/08/26/shadow-dom-introduction/">1</a>, <a href="/blog/2013/08/27/shadow-dom-the-basics/">2</a>, <a href="/blog/2013/08/28/shadow-dom-styles/">3</a>, <a href="/blog/2013/08/29/shadow-dom-styles-cont-dot/">4</a>). The end goal for all of these technologies is <strong>custom elements</strong>, but we're not <em>quite</em> there yet. I want you to understand the basics of working with JavaScript and the shadow DOM before diving head first into making your own elements. So in this post I'm going to explain some things to watch out for, in particular around how events work. With this knowledge under your belt you'll be in a good place to start creating your own custom elements.</p>

<p>Let's get crackin'!</p>

<!--more-->


<p><em>Before we get started I wanted to thank Eric Bidelman for his <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-301/">amazing article on advanced Shadow DOM</a>. Most of this article is my interpretation of his post and I'm only covering a subset of what he presented. Definitely go read <a href="http://www.html5rocks.com/en/tutorials/#webcomponents">everything on HTML5 Rocks that pertains to Web Components</a> when you get a chance.</em></p>

<h2>Support <a href="#" id="support"></a></h2>

<p>In order to try the examples I suggest you use <a href="https://www.google.com/intl/en/chrome/browser/canary.html">Chrome Canary</a> v35 or greater.</p>

<p>Also make sure you've enabled the following in Chrome's <code>about:flags</code>.</p>

<p>√ Experimental Web Platform features<br>
√ Experimental JavaScript<br></p>

<h2>Codez! <a href="#" id="codez"></a></h2>

<p>I've created a sketchbook for this post and future Web Components related stuff. <a href="https://github.com/robdodson/webcomponents-sketchbook">You can grab the sketchbook on GitHub.</a> For each of the examples that I cover I'll link to the sketch so you can quickly try things out.</p>

<h2>JavaScript Scope <a href="#" id="javascript-scope"></a></h2>

<h3>Sketch 13: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/13-javascript-scope">javascript-scope</a></h3>

<p>Remember when I spent all of that time <a href="/blog/2013/08/28/shadow-dom-styles/">explaining how Shadow DOM CSS was encapsulated and protected from the parent document</a> and how awesome that all was? You might also think that JavaScript works the same way—<em>I did at first</em>—but that's actually not the case. With a few exceptions, which I'll discuss later, JavaScript in the Shadow DOM works pretty much exactly as it always has. That means all the best practices you've learned over the years still apply.</p>

<p>Here's an example of what I'm talking about.</p>

<p>```html
<body>
  <div id="host"></div>
  <template></p>

<pre><code>&lt;h1&gt;Hello World!&lt;/h1&gt;
&lt;script&gt;
var foo = 'bar';
&lt;/script&gt;
</code></pre>

<p>  </template>
  <script></p>

<pre><code>var host = document.querySelector('#host');
var root = host.createShadowRoot();
var template = document.querySelector('template');
root.appendChild(document.importNode(template.content, true));
console.log('window.foo = ' + window.foo);
</code></pre>

<p>  </script>
</body>
```
<img class="center" src="http://robdodson.s3.amazonaws.com/images/shadow-dom-js1.jpg" title="'Shadow DOM global variable'" ></p>

<p>Even though we're using a template tag and our script block is inside the Shadow DOM, the <code>foo</code> variable still attaches itself to the <code>window</code>. There's no special magic to keep it out of the global scope. Instead we need to rely on our trusty friend, <a href="http://en.wikipedia.org/wiki/Immediately-invoked_function_expression">the IIFE</a>, to make sure everything stays protected.</p>

<p>```html
<template>
  <h1>Hello World!</h1>
  <script>
  (function () {</p>

<pre><code>var foo = 'bar';
</code></pre>

<p>  }());
  </script>
</template>
```</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/shadow-dom-js2.jpg" title="'Shadow DOM IIFE'" ></p>

<p>That's more like it!</p>

<h2>Event Retargeting <a href="#" id="event-retargeting"></a></h2>

<p>One place where Shadow DOM JavaScript really differs from conventional script is in regard to event dispatching. The thing to remember is that <strong>events originating from nodes inside of the shadow DOM are retargeted so they appear to come from the shadow host.</strong></p>

<p>I know that doesn't really sink in without an example so try this out.</p>

<h3>Sketch 14: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/14-event-retargeting-shadow-nodes">event-retargeting-shadow-nodes</a></h3>

<p>```html
<body>
  <input id="normal-text" type="text" value="I'm normal text"></p>

<p>  <div id="host"></div></p>

<p>  <template></p>

<pre><code>&lt;input id="shadow-text" type="text" value="I'm shadow text"&gt;
</code></pre>

<p>  </template></p>

<p>  <script></p>

<pre><code>var host = document.querySelector('#host');
var root = host.createShadowRoot();
var template = document.querySelector('template');
root.appendChild(document.importNode(template.content, true));

document.addEventListener('click', function(e) {
  console.log(e.target.id + ' clicked!');
});
</code></pre>

<p>  </script>
</body>
```
<a class="jsbin-embed" href="http://jsbin.com/IpaNAMi/3/embed?console,output">Shadow DOM Event Retargeting</a><script src="http://static.jsbin.com/js/embed.js"></script></p>

<p>Click on each of the above text fields and checkout what the console outputs. When you click on the "normal text" field it logs the <code>id</code> of that input. However, when you click on the "shadow text" field it logs the <code>id</code> of the host element (which is just <code>#host</code>). This is because <strong>events coming from shadow nodes have to be retargeted otherwise they would break encapsulation.</strong> If the event target continued to point at <code>#shadow-text</code> then anyone could dig around inside of our Shadow DOM and start messing things up.</p>

<h3>Distributed Nodes</h3>

<p>If you recall from the last post we talked about <a href="/blog/2013/08/29/shadow-dom-styles-cont-dot#distributed-nodes">distributed nodes</a>, which are bits of content taken from the shadow host and projected into the Shadow DOM. You might think that since these nodes appear in the Shadow DOM that their events would be retargeted as well. But that's not the case.</p>

<p>Heres' another example to demonstrate.</p>

<h3>Sketch 15: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/15-event-retargeting-distributed-nodes">event-retargeting-distributed-nodes</a></h3>

<p>```html
<body>
  <input id="normal-text" type="text" value="I'm normal text"></p>

<p>  <div id="host"></p>

<pre><code>&lt;input id="distributed-text" type="text" value="I'm distributed text"&gt;
</code></pre>

<p>  </div></p>

<p>  <template></p>

<pre><code>&lt;div&gt;
  &lt;input id="shadow-text" type="text" value="I'm shadow text"&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;content&gt;&lt;/content&gt;
&lt;/div&gt;
</code></pre>

<p>  </template></p>

<p>  <script></p>

<pre><code>var host = document.querySelector('#host');
var root = host.createShadowRoot();
var template = document.querySelector('template');
root.appendChild(document.importNode(template.content, true));

document.addEventListener('click', function(e) {
  console.log(e.target.id + ' clicked!');
});
</code></pre>

<p>  </script>
</body>
```
<a class="jsbin-embed" href="http://jsbin.com/UyIRUta/2/embed?console,output">Shadow DOM Event Retargeting</a><script src="http://static.jsbin.com/js/embed.js"></script></p>

<p>Like before, as you click on each input field you'll see the id of the event's target element. Clicking on the "distributed text" field shows that its event target remains intact. That's because a distributed node comes from the parent document, so the user already has access to it. There's no need to retarget its events and, in fact, you probably wouldn't want to. If a user gives you a button to style with Shadow DOM they're going to want to be able to listen to click events on it at some point.</p>

<h2>Blocked Events <a href="#" id="blocked-events"></a></h2>

<h3>Sketch 16: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/16-stopped-events">stopped-events</a></h3>

<p>In some instances events are killed off rather than retargeted. The following events are always stopped at the root node and cannot be observed by the parent document:</p>

<ul>
<li><code>abort</code></li>
<li><code>error</code></li>
<li><code>select</code></li>
<li><code>change</code></li>
<li><code>load</code></li>
<li><code>reset</code></li>
<li><code>resize</code></li>
<li><code>scroll</code></li>
<li><code>selectstart</code></li>
</ul>


<p>Here's an example to demonstrate what I mean.</p>

<p>```html
<body>
  <input id="normal-text" type="text" value="I'm normal text"></p>

<p>  <div id="host"></p>

<pre><code>&lt;input id="distributed-text" type="text" value="I'm distributed text"&gt;
</code></pre>

<p>  </div></p>

<p>  <template></p>

<pre><code>&lt;div&gt;
  &lt;content&gt;&lt;/content&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;input id="shadow-text" type="text" value="I'm shadow text"&gt;
&lt;/div&gt;
</code></pre>

<p>  </template>
  <script></p>

<pre><code>var host = document.querySelector('#host');
var root = host.createShadowRoot();
var template = document.querySelector('template');
root.appendChild(document.importNode(template.content, true));

document.addEventListener('select', function(e) {
  console.log(e.target.id + ' text selected!');
});
</code></pre>

<p>  </script>
</body>
```
<a class="jsbin-embed" href="http://jsbin.com/oLuZePo/2/embed?console,output">Shadow DOM Stopped Events</a><script src="http://static.jsbin.com/js/embed.js"></script></p>

<p>Here I'm listening for <code>select</code> events which are triggered whenever you click and drag to highlight some text. If you try highlighting the text inside of the "normal text" input it should log <code>normal-text text selected!</code>. The "distributed text" input reacts in a similar fashion. But if you try to highlight the text inside of the "shadow text" input, nothing appears in the console. The event has been killed at the shadow root so it can't bubble up to the document where our event listener lives. Keep this in mind if you think you need to use any of the above listed events in your Shadow DOM.</p>

<h2>Conclusion <a href="#" id="conclusion"></a></h2>

<p>So nothing <em>too</em> bad I hope. A few gotchas with JavaScript events but otherwise things work pretty much like what we're accustomed to. If you read through the previous posts then you're ready to move on to Custom Elements and <a href="http://www.polymer-project.org/">Polymer</a>! Refer back to these articles if you feel lost and as always be sure to <a href="http://twitter.com/rob_dodson">hit me up on twitter</a> or leave a comment if you have any questions. Thanks!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shadow DOM: Styles (cont.)]]></title>
    <link href="http://robdodson.me/blog/2013/08/29/shadow-dom-styles-cont-dot/"/>
    <updated>2013-08-29T11:11:00-07:00</updated>
    <id>http://robdodson.me/blog/2013/08/29/shadow-dom-styles-cont-dot</id>
    <content type="html"><![CDATA[<p>In <a href="/blog/2013/08/28/shadow-dom-styles/">yesterday's post</a> we covered the basics of working with styles in Shadow DOM. But we've only just scratched the surface! Today we'll continue from where we left off and explore how to work with <strong>distributed nodes</strong> and how to poke holes in our components so the outside world can reach in and customize 'em.</p>

<!--more-->


<p><em>Before we get started I wanted to thank Eric Bidelman for his <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/">amazing article on styling the Shadow DOM</a>. Most of this article is my interpretation of his post. Definitely go read <a href="http://www.html5rocks.com/en/tutorials/#webcomponents">everything on HTML5 Rocks that pertains to Web Components</a> when you get a chance.</em></p>

<h2>Support <a href="#" id="support"></a></h2>

<p>In order to try the examples I suggest you use <a href="https://www.google.com/intl/en/chrome/browser/canary.html">Chrome Canary</a> v31 or greater.</p>

<p>Also make sure you've enabled the following in Chrome's <code>about:flags</code>.</p>

<p>√ Experimental Web Platform features<br>
√ Experimental JavaScript<br></p>

<p><em>I believe Shadow DOM is supported in Chrome without experimental flags but we may touch on other Web Component technologies that require them. Better to just turn them on now I think :)</em></p>

<h2>Codez! <a href="#" id="codez"></a></h2>

<p>I've created a sketchbook for this post and future Web Components related stuff. <a href="https://github.com/robdodson/webcomponents-sketchbook">You can grab the sketchbook on GitHub.</a> For each of the examples that I cover I'll link to the sketch so you can quickly try things out.</p>

<h2>Distributed Nodes <a href="#" id="distributed-nodes"></a></h2>

<h3>Sketch 9: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/09-styling-distributed-nodes">styling-distributed-nodes</a></h3>

<p>From reading various blog posts I learned that when working with the shadow DOM you should make sure to keep your content separate from your presentation. In other words, if you have a button that's going to display some text, that text should come from the page and not be buried in a shadow DOM template. Contents which come from the page and are added to the shadow DOM using the <code>&lt;content&gt;</code> tag are know as <strong>distributed nodes</strong>.</p>

<p>Initially I struggled to understand how it was possible to style these distributed nodes. I kept writing my CSS like this:</p>

<p>```html</p>

<div class="some-shadow-host">
  <button>Hello World!</button>
</div>


<p><template>
  <style></p>

<pre><code>:host {
  ...
}

button {
  font-size: 18px;
}
</code></pre>

<p>  </style>
  <content></content>
</template>
```</p>

<p>Thinking that if <code>button</code> came from the shadow host I should be able to just style it once it was inside my <code>&lt;content&gt;</code> tag. But that's not quite how things work. Instead, distributed nodes need to be styled with the <code>::content</code> pseudo selector. This actually makes sense because we might want buttons inside of our shadow template to be styled differently from buttons which appear inside of our <code>&lt;content&gt;</code> tags.</p>

<p>Let's look at an exmaple:</p>

<p>```html
<body>
  <div class="widget"></p>

<pre><code>&lt;button&gt;Distributed Awesomesauce&lt;/button&gt;
</code></pre>

<p>  </div></p>

<p>  <template class="widget-template"></p>

<pre><code>&lt;style&gt;
  ::content &gt; button {
    font-size: 18px;
    color: white;
    background: tomato;
    border-radius: 10px;
    border: none;
    padding: 10px;
  }
&lt;/style&gt;
&lt;content select=""&gt;&lt;/content&gt;
</code></pre>

<p>  </template></p>

<p>  <script></p>

<pre><code>var host = document.querySelector('.widget');
var root = host.createShadowRoot();
var template = document.querySelector('.widget-template');
root.appendChild(template.content.cloneNode(true));
template.remove();
</code></pre>

<p>  </script>
</body>
```
<img class="center" src="http://robdodson.s3.amazonaws.com/images/shadow-dom-distributed.jpg" title="'Styling distributed shadow DOM nodes'" ></p>

<p>Here we're pulling in the <code>button</code> from our <code>.widget</code> shadow host and tossing it into our <code>&lt;content&gt;</code> tag. Using the <code>::content</code> pseudo selector, we target the <code>button</code> as a child with <code>&gt;</code> and set our fancy pants styles.</p>

<h3>Syntax Changes</h3>

<p>In previous versions of Chrome the syntax for styling distributed nodes looked like this:</p>

<p><code>html
content::-webkit-distributed(&lt;selector&gt;)
</code>
But this style is being deprecated. As of today (August 29, 2013) <code>::content</code> is the proper syntax.</p>

<h2>Parts <a href="#" id="parts"></a></h2>

<h3>Sketch 10: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/10-styling-parts">styling-parts</a></h3>

<p>Up to this point we've celebrated the encapsulation benefits of the shadow DOM but sometimes you want to poke a few holes in the shadow boundary so the user can style your component.</p>

<p>Let's say you're creating a sign in form. Inside of your template you've defined the text size for the inputs but you'd like the user to be able to change this so it fits better with her site. Using the <code>::part</code> pseudo selector and <code>part</code> attribute we can expose any fields we want, thereby giving the user total freedom to override our defaults if they so choose.</p>

<p>```html
<head>
  <style></p>

<pre><code>.sign-up::part(username),
.sign-up::part(password) {
  font-size: 18px;
  border: 1px solid red;
}

.sign-up::part(btn) {
  font-size: 18px;
}
</code></pre>

<p>  </style>
</head>
<body>
  <div class="sign-up"></div></p>

<p>  <template class="sign-up-template"></p>

<pre><code>&lt;style&gt;
  div[part="username"],
  div[part="password"] {
    font-size: 10px;
  }
&lt;/style&gt;
&lt;div&gt;
  &lt;input type="text" id="username" part="username" placeholder="username"&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;input type="password" id="password" part="password" placeholder="password"&gt;
&lt;/div&gt;
&lt;button part="btn"&gt;Sign Up!&lt;/button&gt;
</code></pre>

<p>  </template></p>

<p>  <script></p>

<pre><code>var host = document.querySelector('.sign-up');
var root = host.createShadowRoot();
var template = document.querySelector('.sign-up-template');
root.appendChild(template.content.cloneNode(true));
</code></pre>

<p>  </script>
</body>
```
<img class="center" src="http://robdodson.s3.amazonaws.com/images/shadow-dom-part.jpg" title="'Styling a shadow DOM part'" ></p>

<p>There are three important bits of syntax I want to point out in this example.</p>

<p>The first is <em>how</em> we specify that an element is going to be a <code>part</code>. We do this through the use of the <code>part</code> attribute.</p>

<p><code>html
&lt;input type="text" id="username" part="username" placeholder="username"&gt;
</code></p>

<p>Next we specify a default style for this <code>part</code> using an attribute selector inside of our template.</p>

<p>```html</p>



<p>```</p>

<p>Finally, we reach into the shadow DOM with the <code>::part</code> pseudo selector to override the style defaults.</p>

<p>```html</p>



<p>```</p>

<h3>Syntax Changes</h3>

<p>In previous versions of Chrome the <code>part</code> attribute was known as <code>pseudo</code>. A <code>pseudo</code> attribute would need to be prefixed with an <code>x-</code> and selecting the <code>pseudo</code> attribute looked like this:</p>

<p><code>html
.foo::x-slider-thumb {
  background-color: blue;
}
</code></p>

<p>This syntax is now deprecated and you should use <code>part</code> and <code>::part</code> instead.</p>

<h2>Variables <a href="#" id="variables"></a></h2>

<h3>Sketch 11: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/11-styling-with-variables">styling-with-variables</a></h3>

<p>Working with all of these hard coded styles is making my inner nerd sad. If you've been spoiled by LESS or SCSS, like I have, then you'll quickly be longing for variables to hold all of your configurable values. Thankfully CSS3 variables are supported by the shadow DOM so let's look at how we can tidy things up a bit.</p>

<p>We'll use our previous example but this time we'll work a little variable magic on it:</p>

<p>```html
<head>
  <style></p>

<pre><code>.sign-up {
  var-type-size: 18px;
}

.sign-up::part(username),
.sign-up::part(password) {
  var-borders: 1px solid red;
}
</code></pre>

<p>  </style>
</head>
<body>
  <div class="sign-up"></div></p>

<p>  <template class="sign-up-template"></p>

<pre><code>&lt;style&gt;
  .sign-up::part(username),
  .sign-up::part(password) {
    font-size: var(type-size);
    border: var(borders);
  }

  .sign-up::part(btn) {
    font-size: var(type-size);
  }
&lt;/style&gt;
&lt;div&gt;
  &lt;input type="text" id="username" part="username" placeholder="username"&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;input type="password" id="password" part="password" placeholder="password"&gt;
&lt;/div&gt;
&lt;button part="btn"&gt;Sign Up!&lt;/button&gt;
</code></pre>

<p>  </template></p>

<p>  <script></p>

<pre><code>var host = document.querySelector('.sign-up');
var root = host.createShadowRoot();
var template = document.querySelector('.sign-up-template');
root.appendChild(template.content.cloneNode(true));
</code></pre>

<p>  </script>
</body>
```</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/shadow-dom-part.jpg" title="'Styling a shadow DOM part'" ></p>

<p>We should wind up with the exact same output but things are a bit cleaner now.</p>

<p>Personally I'm not a fan of the CSS3 variable syntax but if you want to go preprocessor free I think it's your best bet.</p>

<h2>Inheriting and Resetting Styles <a href="#" id="inheriting-and-resetting-styles"></a></h2>

<h3>Sketch 12: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/12-inheriting-and-resetting-styles">inheriting-and-resetting-styles</a></h3>

<h3>Applying Author Styles</h3>

<p>If your component contains text or other inheritable properties you may want it to match the page that's hosting it. This is where <code>applyAuthorStyles</code> comes in to play. By setting <code>applyAuthorStyles</code> to <code>true</code> you're telling the document that it's ok for the user's CSS to bleed through and affect your component. This is great for things like typography where you want your component to use the same font families and header sizes as the parent document.</p>

<p>```html
<head>
  <style></p>

<pre><code>body {
  font-family: Helvetica, Arial, sans-serif;
}

h2 {
  text-decoration: underline;
}

p {
  font-size: 18px;
  font-weight: bold;
}
</code></pre>

<p>  </style>
</head>
<body></p>

<p>  <h2>This h2 is NOT in the shadow DOM</h2>
  <p>Neither is this paragraph</p></p>

<p>  <div class="article">Some interesting article content</div></p>

<p>  <template class="article-template"></p>

<pre><code>&lt;h2&gt;An Article Header&lt;/h2&gt;
&lt;p&gt;&lt;content&gt;&lt;/content&gt;&lt;/p&gt;
</code></pre>

<p>  </template></p>

<p>  <script></p>

<pre><code>var host = document.querySelector('.article');
var root = host.createShadowRoot();
root.applyAuthorStyles = true;
// Note that you can also reset styles on a per &lt;shadow&gt; or
// per &lt;content&gt; basis
// http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/#toc-shadow-resetstyles
var template = document.querySelector('.article-template');
root.appendChild(template.content.cloneNode(true));
template.remove();
</code></pre>

<p>  </script>
</body>
```
<img class="center" src="http://robdodson.s3.amazonaws.com/images/shadow-dom-author-styles.jpg" title="'Applying author styles'" ></p>

<p>If we take a look at the CSS we can see that the user has directly styled all <code>h2</code>'s and <code>p</code>'s. Also everything on the page should inherit a <code>font-family</code> of Helvetica. By using <code>applyAuthorStyles</code> we've allowed the direct styles <em>and</em> the inherited <code>font-family</code> to bleed through.</p>

<h3>Reseting Inheritance</h3>

<p>In some cases we may wish to only allow the direct styles while resetting anything that would be inherited. Using the example above that would mean excluding the <code>font-family</code> of Helvetica which is inherited from the <code>body</code> style. To reset style inheritance we use the aptly named <code>resetStyleInheritance</code> method.</p>

<p>```html</p>

<script>
  var host = document.querySelector('.article');
  var root = host.createShadowRoot();
  root.resetStyleInheritance = true; // <-- get rid of anything inherited
  root.applyAuthorStyles = true;
  var template = document.querySelector('.article-template');
  root.appendChild(template.content.cloneNode(true));
  template.remove();
</script>


<p>```
<img class="center" src="http://robdodson.s3.amazonaws.com/images/shadow-dom-reset-inheritance.jpg" title="'Reset style inheritance'" ></p>

<p>Now our component reverts to the default <code>font-family</code> of Times New Roman while still allowing direct author styles on <code>h2</code> and <code>p</code>. <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/#style-inherit-cheetsheet">Eric Bidelman's great post on Shadow DOM 201 has a handy cheat sheet</a> so you can sort out when you want to use <code>applyAuthorStyles</code> and when you want to use <code>resetStyleInheritance</code>.</p>

<h2>Conclusion <a href="#" id="conclusion"></a></h2>

<p>If you've read over <a href="/blog/2013/08/28/shadow-dom-styles/">the last post</a> and this one then you now know as much about styling the shadow DOM as I do. But we haven't even talked about JavaScript yet! We'll save that for tomorrow's post :) As always if you have questions <a href="http://twitter.com/rob_dodson">hit me up on twitter</a> or leave a comment. Thanks!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shadow DOM: Styles]]></title>
    <link href="http://robdodson.me/blog/2013/08/28/shadow-dom-styles/"/>
    <updated>2013-08-28T10:56:00-07:00</updated>
    <id>http://robdodson.me/blog/2013/08/28/shadow-dom-styles</id>
    <content type="html"><![CDATA[<p><a href="/blog/2013/08/27/shadow-dom-the-basics/">Yesterday's post</a> was all about coding and structuring your first Shadow DOM elements. But I'm sure most of you were wondering, how do we style these things?!</p>

<p>The use of CSS in Shadow DOM is an interesting and large topic. So large, in fact, that I'm going to split it up over the next couple of posts. Today we'll learn the basics of using CSS within the <strong>shadow boundary</strong>, and also how to style our <strong>shadow hosts</strong>.</p>

<!--more-->


<p><em>Before we get started I wanted to thank Eric Bidelman for his <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/">amazing article on styling the Shadow DOM</a>. Most of this article is my interpretation of his post. Definitely go read <a href="http://www.html5rocks.com/en/tutorials/#webcomponents">everything on HTML5 Rocks that pertains to Web Components</a> when you get a chance.</em></p>

<h2>Support <a href="#" id="support"></a></h2>

<p>In order to try the examples I suggest you use <a href="https://www.google.com/intl/en/chrome/browser/canary.html">Chrome Canary</a> v31 or greater.</p>

<p>Also make sure you've enabled the following in Chrome's <code>about:flags</code>.</p>

<p>√ Experimental Web Platform features<br>
√ Experimental JavaScript<br></p>

<p><em>I believe Shadow DOM is supported in Chrome without experimental flags but we may touch on other Web Component technologies that require them. Better to just turn them on now I think :)</em></p>

<h2>Codez! <a href="#" id="codez"></a></h2>

<p>I've created a sketchbook for this post and future Web Components related stuff. <a href="https://github.com/robdodson/webcomponents-sketchbook">You can grab the sketchbook on GitHub.</a> For each of the examples that I cover I'll link to the sketch so you can quickly try things out.</p>

<h2>Style Encapsulation <a href="#" id="style-encapsulation"></a></h2>

<h3>Sketch 4: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/04-style-encapsulation">style-encapsulation</a></h3>

<p>Astute readers probably noticed that I used a new term in the introduction for this post. That term is <strong>shadow boundary</strong> and it refers to the barrier that separates the regular DOM (the "light" DOM) from the shadow DOM. One of the primary benefits of the shadow boundary is that it prevents styles that are in the main document from leaking into the shadow DOM. This means that even though you might have a selector in your main document for all <code>&lt;h3&gt;</code> tags, that style will not be applied to your shadow DOM element unless you specifically allow it.</p>

<p>Examples? Yes, let's.</p>

<p>```html
<body></p>

<pre><code>&lt;style&gt;
  button {
    font-size: 18px;
    font-family: cursive;
  }
&lt;/style&gt;
&lt;button&gt;I'm a regular button&lt;/button&gt;
&lt;div&gt;&lt;/div&gt;

&lt;script&gt;
  var host = document.querySelector('div');
  var root = host.createShadowRoot();
  root.innerHTML = '&lt;style&gt;button { font-size: 24px; color: blue; } &lt;/style&gt;' +
                   '&lt;button&gt;I\'m a shadow button&lt;/button&gt;'
&lt;/script&gt;
</code></pre>

<p>  </body>
```</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/shadow-dom-styles1.jpg" title="'Shadow DOM style encapsulation'" ></p>

<p>Here we have two buttons. One is in the regular DOM, and the other is in the shadow DOM. You'll notice that the style tag at the top of the page instructs all buttons to use a cursive font and to have a <code>font-size</code> of 18px.</p>

<p>```html</p>



<p><code>``
Because of the shadow boundary, the second button ignores this style tag and instead implements its own look. We never specifically override the</code>font-family` to change it back to sans serif, it just uses the typical browser defaults.</p>

<p>Keep in mind that the shadow boundary also protects the main document from the shadow DOM. You'll notice that our shadow button has a <code>color</code> of blue. But the button in the original document maintains its default appearance.</p>

<p>This kind of <strong>encapsulation</strong> is pretty amazing. For years we've struggled with style sheets that always seem to get bigger and bigger. Over time it can be difficult to add new styles because you're worried you'll break something elsewhere on the page. The style boundaries provided to us by the shadow DOM means that we can finally start to think about our CSS in a more local, component specific way.</p>

<h2>Styling :host <a href="#" id="styling-host"></a></h2>

<h3>Sketch 5: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/05-styling-host">styling-host</a></h3>

<p>I often think of the shadow host as if it's the exterior of a building. Inside there's all the inner workings of my widget and outside there should be a nice facade. In many cases you'll want to apply some style to this exterior and that's where the <code>:host</code> selector comes into play.</p>

<p>```html
<body>
  <style></p>

<pre><code>.widget {
  text-align: center;
}
</code></pre>

<p>  </style></p>

<p>  <div class="widget"></p>

<pre><code>&lt;p&gt;Hello World!&lt;/p&gt;
</code></pre>

<p>  </div></p>

<p>  <script></p>

<pre><code>var host = document.querySelector('.widget');
var root = host.createShadowRoot();
root.innerHTML = '&lt;style&gt;' +
                 ':host {' +
                 '  border: 2px dashed red;' +
                 '  text-align: left;' +
                 '  font-size: 28px;' +
                 '} ' +
                 '&lt;/style&gt;' +
                 '&lt;content&gt;&lt;/content&gt;';
</code></pre>

<p>  </script>
</body>
```</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/shadow-dom-styles2.jpg" title="'Shadow DOM host styles'" ></p>

<p>Adding a red border to our widget doesn't seem like much but there's actually a number of interesting things happening here. For starters, notice that styles applied to the <code>:host</code> are inherited by elements within the shadow DOM. So our <code>&lt;p&gt;</code> ends up with a <code>font-size</code> of 28px.</p>

<p>Also notice that the page is able to set the <code>text-align</code> inside the <code>:host</code> to center. The <code>:host</code> selector has low specificity by design, so it's easier for the document to override it if it needs to. In this case the document style for <code>.widget</code> beats out the shadow style for <code>:host</code>.</p>

<h2>Styling by :host Type <a href="#" id="styling-by-host-type"></a></h2>

<h3>Sketch 6: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/06-styling-by-host-type">styling-host-by-host-type</a></h3>

<p>Because <code>:host</code> is a pseudo selector we can apply it to more than one tag to change the appearance of our component. Let's do another example to demonstrate.</p>

<p>```html
<body>
  <p>My Paragraph</p>
  <div>My Div</div>
  <button>My Button</button></p>

<p>  <!-- Our template -->
  <template class="shadow-template"></p>

<pre><code>&lt;style&gt;
  p:host {
    color: blue;
  }

  div:host {
    color: green;
  }

  button:host {
    color: red;
  }

  *:host {
    font-size: 24px;
  }
&lt;/style&gt;
&lt;content select=""&gt;&lt;/content&gt;
</code></pre>

<p>  </template></p>

<p>  <script></p>

<pre><code>// Create a shadow root for each element
var root1 = document.querySelector('p').createShadowRoot();
var root2 = document.querySelector('div').createShadowRoot();
var root3 = document.querySelector('button').createShadowRoot();

// We'll use the same template for each shadow root
var template = document.querySelector('.shadow-template');

// Stamp the template into each shadow root. Notice how
// the different :host styles affect the appearance
root1.appendChild(template.content.cloneNode(true));
root2.appendChild(template.content.cloneNode(true));
root3.appendChild(template.content.cloneNode(true));
</code></pre>

<p>  </script>
</body>
```</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/shadow-dom-styles3.jpg" title="'Shadow DOM styling by host type'" ></p>

<p><em>I've switched to using a <a href="/blog/2013/03/16/html5-template-tag-introduction/">template tag</a> for this example since it makes working with the Shadow DOM a lot easier.</em></p>

<p>As you can see from the example above, we're able to change the look of our component by matching the <code>:host</code> selector to a specific tag. We can also match against classes, IDs, attributes, etc. Really any valid CSS will do.</p>

<p>For instance, you could have <code>.widget-fixed</code>, <code>.widget-flex</code> and <code>.widget-fluid</code> <code>:hosts</code> if you wanted to build a highly responsive component. Or <code>.valid</code> and <code>.error</code> <code>:hosts</code> for form elements.</p>

<p>By using the <code>*</code> selector we're able to create default styles which will apply to any <code>:host</code>, in this case setting all components to a <code>font-size</code> of 24px. This way you can construct the basic look for your component and then augment it with different <code>:host</code> types.</p>

<p>What about theming hosts based on their parent element? Well, there's a selector for that too!</p>

<h2>Theming <a href="#" id="theming"></a></h2>

<h3>Sketch 7: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/07-theming">theming</a></h3>

<p>```html
<body>
  <div class="serious"></p>

<pre><code>&lt;p class="serious-widget"&gt;
  I am super serious, guys.
&lt;/p&gt;
</code></pre>

<p>  </div></p>

<p>  <div class="playful"></p>

<pre><code>&lt;p class="playful-widget"&gt;
  Pretty little clouds...
&lt;/p&gt;
</code></pre>

<p>  </div></p>

<p>  <template class="widget-template"></p>

<pre><code>&lt;style&gt;
  :host(.serious) {
    width: 200px;
    height: 50px;
    padding: 50px;
    font-family: monospace;
    font-weight: bold;
    font-size: 24px;
    color: black;
    background: tomato;
  }

  :host(.playful) {
    width: 200px;
    height: 50px;
    padding: 50px;
    font-family: cursive;
    font-size: 24px;
    color: white;
    background: deepskyblue;
  }
&lt;/style&gt;
&lt;content&gt;&lt;/content&gt;
</code></pre>

<p>  </template>
  <script></p>

<pre><code>var root1 = document.querySelector('.serious-widget').createShadowRoot();
var root2 = document.querySelector('.playful-widget').createShadowRoot();
var template = document.querySelector('.widget-template');
root1.appendChild(template.content.cloneNode(true));
root2.appendChild(template.content.cloneNode(true));
</code></pre>

<p>  </script>
</body>
```
<img class="center" src="http://robdodson.s3.amazonaws.com/images/shadow-dom-styles5.jpg" title="'Shadow DOM theming'" ></p>

<p>Using <code>:host()</code> syntax we're able to completely change the look of our widget based on the containing element. This is pretty neat! I'm sure you've all used the child selector before, <code>.parent &gt; .child</code>, but have you ever wished for a parent selector, <code>.parent &lt; .child</code>? Now it's possible, but only with the shadow DOM. I wonder if we'll see this syntax tracked back to normal CSS someday?</p>

<h2>Styling :host States <a href="#" id="styling-host-states"></a></h2>

<h3>Sketch 8: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/08-styling-host-states">styling-host-states</a></h3>

<p>One of the best uses of the <code>:host</code> tag is for styling states like <code>:hover</code> or <code>:active</code>. For instance, let's say you want to add a green border to a button when the user rolls over it. Easy!</p>

<p>```html
<body>
  <button>My Button</button></p>

<p>  <template class="button-template"></p>

<pre><code>&lt;style&gt;
  *:host {
    font-size: 18px;
    cursor: pointer;
  }
  *:host:hover {
    border: 2px solid green;
  }
&lt;/style&gt;
&lt;content&gt;&lt;/content&gt;
</code></pre>

<p>  </template>
  <script></p>

<pre><code>var host = document.querySelector('button');
var root = host.createShadowRoot();
var template = document.querySelector('.button-template');
root.appendChild(template.content.cloneNode(true));
</code></pre>

<p>  </script>
</body>
```
<img class="center" src="http://robdodson.s3.amazonaws.com/images/shadow-dom-styles4.jpg" title="'Shadow DOM host state'" ></p>

<p>Nothing fancy but hopefully it gets your imagination going a bit. What other states do you think you could create?</p>

<h2>Conclusion <a href="#" id="conclusion"></a></h2>

<p>There's still a lot more to talk about when it comes to styling the Shadow DOM. Let's take a break for today and pick it up again tomorrow. As always if you have questions <a href="http://twitter.com/rob_dodson">hit me up on twitter</a> or leave a comment. Thanks!</p>

<h2><a href="/blog/2013/08/29/shadow-dom-styles-cont-dot/">Continue to Shadow DOM: Styles (cont.) &rarr;</a></h2>
]]></content>
  </entry>
  
</feed>
