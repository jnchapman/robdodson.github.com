<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Template | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/template/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2014-04-14T10:32:04-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Repeating Templates in Polymer]]></title>
    <link href="http://robdodson.me/blog/2013/11/12/repeating-templates-in-polymer/"/>
    <updated>2013-11-12T15:14:00-08:00</updated>
    <id>http://robdodson.me/blog/2013/11/12/repeating-templates-in-polymer</id>
    <content type="html"><![CDATA[<p>I ran into a little issue this afternoon working with templates in Polymer and I wanted to quickly jot down my thoughts in case others bump up against this.</p>

<!-- more -->


<h2>Bindings</h2>

<p>Bindings allow you to easily pipe some data into your markup from a JavaScript object of some kind. If you've worked with a library like Mustache or Handlebars before then they should feel familiar.</p>

<p>In Polymer land, the <code>&lt;template&gt;</code> tag has been extended so it supports a few handy binding attributes. These include <code>bind</code>, <code>repeat</code>, <code>if</code>, and <code>ref</code>.</p>

<h2>How Not to Do It</h2>

<p>If you take a look at the Polymer docs on <a href="http://www.polymer-project.org/platform/template.html">template bindings</a> you'll notice that the binding attribute (<code>bind</code>, <code>repeat</code>, etc.) is always located on the first template. For instance:</p>

<p><code>
&lt;template repeat="&amp;#123;{ collection }}"&gt;
  Creates an instance with  for every element in the array collection.
&lt;/template&gt;
</code></p>

<p>This lead me to believe that I should write my element like this:</p>

<p>```
<polymer-element name="polymer-letters">
  <template repeat="&#123;{ letter in letters }}"></p>

<pre><code>&amp;#123;{ letter }}
</code></pre>

<p>  </template>
  <script></p>

<pre><code>Polymer('polymer-letters', {
  letters: ['a', 'b', 'c']
});
</code></pre>

<p>  </script>
</polymer-element>
```</p>

<p>But unfortunately that does not work <span style="color: grey;">#sadtrombone.</span></p>

<h2>The Right Way</h2>

<p>Polymer uses the first <code>template</code> element to create Shadow DOM, so if you want to use a binding <strong>you'll need to nest it <em>inside</em> another template.</strong></p>

<p>Our updated example would look like this:</p>

<p>```
<polymer-element name="polymer-letters">
  <template></p>

<pre><code>&lt;template repeat="&amp;#123;{ letter in letters }}"&gt;
  &amp;#123;{ letter }}
&lt;/template&gt;
</code></pre>

<p>  </template>
  <script></p>

<pre><code>Polymer('polymer-letters', {
  letters: ['a', 'b', 'c']
});
</code></pre>

<p>  </script>
</polymer-element>
```</p>

<p>And here it is running on CodePen:</p>

<p data-height="268" data-theme-id="0" data-slug-hash="wxrqf" data-user="robdodson" data-default-tab="html" class='codepen'>See the Pen <a href='http://codepen.io/robdodson/pen/wxrqf'>Polymer Template Bindings</a> by Rob Dodson (<a href='http://codepen.io/robdodson'>@robdodson</a>) on <a href='http://codepen.io'>CodePen</a></p>


<script async src="http://robdodson.me//codepen.io/assets/embed/ei.js"></script>


<p>I mentioned this to Eric Bidelman and he opened <a href="https://github.com/Polymer/docs/issues/191">a ticket to improve the docs</a>, so keep an eye out for that. Hope this helps some of you that may have been stuck :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web Components Resources]]></title>
    <link href="http://robdodson.me/blog/2013/08/22/web-components-resources/"/>
    <updated>2013-08-22T17:47:00-07:00</updated>
    <id>http://robdodson.me/blog/2013/08/22/web-components-resources</id>
    <content type="html"><![CDATA[<p>Eric Bidelman (<a href="http://twitter.com/ebidel">@ebidel</a>) put together <a href="https://gist.github.com/ebidel/6314025">a great list of Web Components Resources</a>. It's nice to have it all in one place because it sure can get confusing hoping around from spec to article to slideshow, etc. If you have more resources make sure to do a PR and add them to the list!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploring HTML Imports]]></title>
    <link href="http://robdodson.me/blog/2013/08/20/exploring-html-imports/"/>
    <updated>2013-08-20T13:07:00-07:00</updated>
    <id>http://robdodson.me/blog/2013/08/20/exploring-html-imports</id>
    <content type="html"><![CDATA[<p><a href="http://robdodson.me/blog/2013/03/17/why-web-components/">Web Components</a> have come a long way in the past few months and one of the technologies that I'm most interested in is <a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/imports/index.html">HTML Imports</a> (or "imports", for short). Imports allow you to load additional documents into your page without having to write a bunch of ajax. This is great for <a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/index.html">Custom Elements</a> where you might want to import a suite of new tags. I spent the day playing with imports and thought it would be useful to write up my progress.</p>

<!--more-->


<h2>The Lowdown</h2>

<p>Imports are a new type of <code>link</code> tag which should be familiar to you since that's also how we load our stylesheets.</p>

<p><code>html
&lt;link rel="stylesheet" href="http://robdodson.me/path/to/styles.css"&gt;
</code></p>

<p>For an import we just replace the <code>rel</code> with one of type <code>import</code>.</p>

<p><code>html
&lt;link rel="import" href="http://robdodson.me/path/to/some/import.html"&gt;
</code></p>

<p>At the moment, imports do not block like script tags. However, that may change in the future to help with <a href="http://lists.w3.org/Archives/Public/public-webapps/2013JulSep/0287.html">Custom Element resolution.</a></p>

<h2>Support</h2>

<p>Native imports are only available in Chrome Canary v31 and Chrome Dev v30. Thankfully <a href="http://www.polymer-project.org/">Polymer</a> <a href="http://www.polymer-project.org/platform/html-imports.html">offers a polyfill</a> if you want to try them out in other modern / "evergreen" browsers.</p>

<p>To use HTML Imports make sure you've enabled the following
in Chrome's <code>about:flags</code>.</p>

<p>√ Experimental Web Platform features<br>
√ HTML Imports<br></p>

<h2>Codez!</h2>

<p>I've created a sketchbook for this post and future Web Components related stuff. <a href="https://github.com/robdodson/webcomponents-sketchbook">You can grab the sketchbook on GitHub.</a> For each of the examples that I cover I'll link to the sketch so you can quickly try things out.</p>

<h2>A Basic Example</h2>

<h3>Sketch 0: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/html-imports/0-basic">Basic</a></h3>

<p>OK so what's a very basic import look like?</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Basic HTML Imports&lt;/title&gt;
&lt;!-- Pull in our blog post example --&gt;
&lt;link rel="import" href="http://robdodson.me/imports/blog-post.html"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;p&gt;Hello World!&lt;/p&gt;
</code></pre>

<p>  </body>
</html>
```
In its simplest form the import works just like calling a stylesheet. We have to make sure there's a document to import so let's create a fake blog post.</p>

<p>``` html imports/blog-post.html</p>

<div id="blog-post">
  <h1>Awesome header</h1>
  <p>Here is some really interesting paragraph content.</p>
</div>


<p>```</p>

<p>To test you'll need to host your <code>index.html</code> and <code>imports/</code> folder on a local server. I recommend <a href="https://github.com/visionmedia/serve">serve</a> if you don't already have one installed.</p>

<p>Once you have that setup visit your index page. If you take a look at the console you can see the request returning.</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/imports-console.jpg" title="'Our first HTML import!'" ></p>

<p>Well that's cool, but now what?</p>

<p>Let's grab the content of the import using some JavaScript and append it to the body.</p>

<p>``` html index.html
<body>
  <p>Hello World!</p></p>

<p>  <script></p>

<pre><code>var link = document.querySelector('link[rel=import]');
var content = link.import.querySelector('#blog-post');
document.body.appendChild(content.cloneNode(true));
</code></pre>

<p>  </script>
</body>
<code>``
First we query the</code>link<code>tag which loaded our import. Then we extract our</code>#blog-post<code>element and store it in a variable called</code>content<code>. You'll notice that we don't have to write any event handler code to wait till the import has loaded, we can just assume the content is there and start working with it. Finally we add the new content to our</code>body`.</p>

<p>If you're following along you should end up with something like this:</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/imports-screen1.jpg" title="'Basic Import Example'" ></p>

<p>Exciting, I know ;) But it demonstrates a no frills approach to loading content that doesn't require ajax and writing our own event handlers. Let's keep digging to see what else we find...</p>

<h2>A Basic Example with Polymer</h2>

<h3>Sketch 1: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/html-imports/1-basic-polymer">Basic-Polymer</a></h3>

<p>If you want to try out the snippets above in a browser other than Chrome Canary you'll need to use Google's <a href="http://www.polymer-project.org/">Polymer Project</a>. Polymer is a collection of polyfills and additional sugars which seeks to enable the use of Web Components in all modern browsers. The hope is that devolopers will use Polymer to inform the W3C on which direction to take with Web Components; so rather than wait for a stinky spec we can guide the implementation process.</p>

<p>Polymer attempts to keep parity with the the evolving specifications but obviously there are some places where the API must differ because of the limitations of current browsers. In the case of HTML Imports, Polymer waits for the <code>DOMContentLoaded</code> event before triggering the actual import process. This means we need to listen for the <code>HTMLImportsLoaded</code> event on either <code>window</code> or <code>document</code> to know when it is finished.</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Basic HTML Imports&lt;/title&gt;
&lt;link rel="import" href="http://robdodson.me/imports/blog-post.html"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;p&gt;Hello World!&lt;/p&gt;

&lt;!-- Include polymer.js --&gt;
&lt;script src="http://robdodson.me/bower_components/polymer/polymer.min.js"&gt;&lt;/script&gt;

&lt;!-- Listen for the HTMLImportsLoaded event --&gt;
&lt;script&gt;
  window.addEventListener('HTMLImportsLoaded', function() {
    var link = document.querySelector('link[rel=import]');
    var content = link.import.querySelector('#blog-post');
    document.body.appendChild(content.cloneNode(true));
  });
&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```
Using the above we should get the same results as before.</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/imports-screen1.jpg" title="'Basic Import Example with Polymer'" ></p>

<p>You might notice that I used <code>polymer.min.js</code> instead of only including the <a href="http://www.polymer-project.org/platform/html-imports.html">HTML Imports polyfill</a>. Polymer is structured so you can take any of the polyfills &agrave; la carte but I find it's easier to just include all of Polymer when I'm experimenting, rather than worry if I have each individual polyfill loaded. That's just personal preference (aka I'm lazy).</p>

<h2>Using CSS in our Imports</h2>

<h3>Sketch 2: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/html-imports/2-css">CSS</a></h3>

<p>Let's put Polymer to the side for a bit and go back to our original, native example.</p>

<p>One of the first things I wanted to try was importing documents using the new CSS <a href="http://www.w3.org/TR/html51/document-metadata.html#attr-style-scoped"><code>scoped</code></a> attribute. The <code>scoped</code> attribute allows you to include <code>&lt;style&gt;</code> tags inside of an element which <strong>only affect that element and not the entire document</strong>. Let's update our index file a bit to demonstrate:</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Imports with CSS&lt;/title&gt;
&lt;link rel="import" href="http://robdodson.me/imports/blog-post.html"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;!-- Add a header so we can show off scoped --&gt;
&lt;h1&gt;Boring header&lt;/h1&gt;
&lt;p&gt;Hello World!&lt;/p&gt;

&lt;script&gt;
  var link = document.querySelector('link[rel=import]');
  var content = link.import.querySelector('#blog-post');
  document.body.appendChild(content.cloneNode(true));
&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
<code>``
The only change I've made is to add an</code>h1<code>at line 10 so we can better illustrate how</code>scoped` works. Now let's update our fake blog post.</p>

<p>``` html imports/blog-post.html</p>

<div id="blog-post">
  <style scoped>
    h1 {
      background: lightgreen;
      color: green;
    }

    p {
      font-size: 16px;
      font-family: Helvetica, Arial, sans-serif;
      color: green;
      font-weight: bold;
    }
  </style>

  <h1>Awesome header</h1>
  <p>
    Here is some really interesting paragraph content.
    It comes with its own stylesheet!
  </p>
</div>


<p>```
When we run this in Canary we should get the following:</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/imports-screen2.jpg" title="'Imports with Scoped Styles'" ></p>

<p>It's still not much to look at but the gears in my imagination are starting to turn now. We just imported a document, which has its own styles that are scoped specifically to it, and we stamped its contents onto our page. We're starting to get into Web Components territory and that's pretty exciting. Let's see what else we can do...</p>

<h2>Using Scripts in our Imports</h2>

<h3>Sketch 3: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/html-imports/3-script">Script</a></h3>

<p>Next let's look at using <code>&lt;script&gt;</code> tags inside of our import. We'll start by removing the <code>&lt;script&gt;</code> block from our <code>index.html</code>.</p>

<p>```html index.html
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Basic HTML Imports&lt;/title&gt;
&lt;link rel="import" href="http://robdodson.me/imports/blog-post.html"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;h1&gt;Boring header&lt;/h1&gt;
&lt;p&gt;Hello World!&lt;/p&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>Then we'll transfer that script block over to our blog post.</p>

<p>```html imports/blog-post.html</p>

<div id="blog-post">
  <style scoped>
    h1 {
      background: lightgreen;
      color: green;
    }

    p {
      font-size: 16px;
      font-family: Helvetica, Arial, sans-serif;
      color: green;
      font-weight: bold;
    }
  </style>

  <h1>Awesome header</h1>
  <p>
    Here is some really interesting paragraph content.
    It comes with its own stylesheet!
  </p>
</div>




<script>
  // thisDoc refers to the "importee", which is blog-post.html
  var thisDoc = document.currentScript.ownerDocument;

  // thatDoc refers to the "importer", which is index.html
  var thatDoc = document;

  // grab the contents of the #blog-post from this document
  // and append it to the importing document.
  var content = thisDoc.querySelector('#blog-post');
  thatDoc.body.appendChild(content.cloneNode(true));
</script>


<p>```
If we run this we should get the exact same outcome as before.</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/imports-screen2.jpg" title="'Imports with Scoped Styles'" ></p>

<p>An important thing to take notice of is the relationship between <code>thisDoc</code> and <code>thatDoc</code>. <code>thisDoc</code> refers to the <code>blog-post.html</code> document, while <code>thatDoc</code> refers to our index.html file. It's useful to distinguish between the two so we can <code>querySelector</code> for <code>#blog-post</code> and not worry that we may have grabbed something out of the importing document. <em>Thanks to <a href="https://twitter.com/coonsta">Dominic Cooney</a> for the heads up on this.</em></p>

<p>You'll also notice that since the import has access to our <code>document</code> object it is able to add itself to the page. In practice you probably wouldn't want imports adding themselves wherever but the important takeaway is that <strong>anything imported can access the <code>document</code></strong>. This means an import could register itself as a Custom Element using our <code>document</code> object and we wouldn't need to write any additional code. We're almost to that point so let's keep going...</p>

<h2>Using Templates in our Imports</h2>

<h3>Sketch 4: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/html-imports/4-template">Template</a></h3>

<p>I'm getting a little tired of our fake "blog post" so let's switch over to something more practical. We'll use <a href="http://www.chartjs.org/">Chart.js</a> to create a very simple pie diagram and we'll use the new <code>&lt;template&gt;</code> tag to hold the contents of our import. If you haven't heard of the template tag before <a href="http://robdodson.me/blog/2013/03/16/html5-template-tag-introduction/">checkout this introduction</a>.</p>

<p>To start, I've updated the <code>index.html</code> so it includes Chart.js and imports a new <code>chart.html</code> file.</p>

<p>```html index.html
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Imports with Templates&lt;/title&gt;
&lt;!-- Include Chart.js so our import can use it --&gt;
&lt;script src="http://robdodson.me/lib/chart.min.js"&gt;&lt;/script&gt;
&lt;!-- Make sure to import chart.html --&gt;
&lt;link rel="import" href="http://robdodson.me/imports/chart.html"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;h1&gt;Quarterly Pokemon Sales&lt;/h1&gt;
</code></pre>

<p>  </body>
</html>
<code>``
Originally I had the Chart.js script include on line 7 inside of</code>chart.html<code>. I realize now that this is an antipattern because</code>chart.html` has no idea where you would store your 3rd party libraries. If your import depends on 3rd party code I think it's best to keep it in the primary document.</p>

<p>Here's what <code>chart.html</code> looks like:</p>

<p>```html imports/chart.html
<template id="chart-pie">
  <canvas id="myChart" width="200" height="200"></canvas>
  <script></p>

<pre><code>var data = [
  {
    value: 30,
    color:"#F38630"
  },
  {
    value : 50,
    color : "#E0E4CC"
  },
  {
    value : 100,
    color : "#69D2E7"
  }
];

// Get the context of the canvas element we want to select
// It's ok to use document here because this script block won't
// activate till it's added to the page.
var ctx = document.getElementById("myChart").getContext("2d");
var myNewChart = new Chart(ctx).Pie(data);
</code></pre>

<p>  </script>
</template></p>

<script>
  // thisDoc refers to the "importee", which is chart.html
  var thisDoc = document.currentScript.ownerDocument;

  // thatDoc refers to the "importer", which is index.html
  var thatDoc = document;

  // grab the contents of #chart-pie from this document
  // and append it to the importing document.
  var template = thisDoc.querySelector("#chart-pie");
  thatDoc.body.appendChild(template.content.cloneNode(true));
</script>


<p><code>``
We're creating a new</code><template>` which contains a canvas tag and a script block to create our pie chart. The advantage of using a template tag is that any script blocks inside of it will not execute until we clone the contents and add them to the DOM.</p>

<p>Lines 29-37 should look familiar. We're grabbing the template and stamping its content onto the document. Notice on line 37 we use <code>template.content</code> to access the innards.</p>

<p>Running the above gives us this:</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/imports-template.jpg" title="'Imports with Template'" ></p>

<p>Well this is interesting. We're importing an entire pie chart and our index page isn't cluttered with a bunch of code. Unfortunately we don't have much control over where the pie chart ends up. It would be nice if we could turn the contents of the import into a tag and place that wherever. Thankfully Custom Elements let us do just that!</p>

<h2>Using Custom Elements in our Imports</h2>

<h3>Sketch 5: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/html-imports/5-custom-element">Custom Element</a></h3>

<p>I'll say in advance that you might need to read through this section a few times before you fully grok it. We're going to touch on a lot of new stuff and I fully admit that I don't understand it all just yet. Consider this the bonus round :)</p>

<p>Having said that, the final markup for our <code>index.html</code> file is going to look like this:</p>

<p>```html index.html
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Imports with Custom Elements&lt;/title&gt;
&lt;script src="http://robdodson.me/lib/chart.min.js"&gt;&lt;/script&gt;
&lt;link rel="import" href="http://robdodson.me/imports/chart.html"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;h1&gt;Quarterly Pokemon Sales&lt;/h1&gt;
&lt;chart-pie&gt;&lt;/chart-pie&gt;
&lt;chart-pie&gt;&lt;/chart-pie&gt;
&lt;chart-pie&gt;&lt;/chart-pie&gt;
</code></pre>

<p>  </body>
</html>
<code>``
On lines 11-13 we're going to use our new Custom Element,</code>chart-pie`, which will allow us to produce pie charts wherever we want. The result will look like this:</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/imports-custom-elements.jpg" title="'Imports with Custom Elements'" ></p>

<p>Obviously not the most amazing thing ever but from a practical perspective being able to drop a pie chart on your page with one line of HTML is pretty sweet.</p>

<p>To create the <code>chart-pie</code> tag we'll need to create a <a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/index.html">Custom Element</a>. Custom Elements are new tags with a lifecycle of JavaScript callbacks. Typically they use <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/">Shadow DOM</a> to hide their internal markup and expose attributes and specific styles to the client. <a href="http://robdodson.me/blog/2013/03/17/why-web-components/">I wrote an article loosely explaining them</a> a while back so take a look at that and also checkout <a href="http://www.youtube.com/watch?v=fqULJBBEVQE">this talk by Eric Bidelman</a>.</p>

<p>Here's what our updated <code>chart.html</code> looks like.</p>

<p>```html imports/chart.html
<template id="chart-pie">
  <canvas class="myChart" width="200" height="200"></canvas>
</template></p>

<script>
  // thisDoc refers to the "importee", which is chart.html
  var thisDoc = document.currentScript.ownerDocument;

  // thatDoc refers to the "importer", which is index.html
  var thatDoc = document;

  var template = thisDoc.querySelector('#chart-pie');

  // Make sure you extend an existing HTMLElement prototype
  var ChartPieProto = Object.create(HTMLElement.prototype);

  // Setup optional lifecycle callbacks: createdCallback,
  // enteredDocumentCallback, leftDocumentCallback and
  // attributeChangedCallback
  ChartPieProto.createdCallback = function() {
    // Create a ShadowDOM to hold our template content
    var root = this.createShadowRoot();
    var clone = template.content.cloneNode(true);

    // Create the pie chart with Chart.js
    var data = [
      {
        value: 30,
        color:"#F38630"
      },
      {
        value : 50,
        color : "#E0E4CC"
      },
      {
        value : 100,
        color : "#69D2E7"
      }
    ];

    //Get the context of the canvas element we want to select
    var ctx = clone.querySelector('.myChart').getContext('2d');
    var myNewChart = new Chart(ctx).Pie(data);

    // Add the template content + chart to our Shadow DOM
    root.appendChild(clone);
  };

  var ChartPie = thatDoc.register('chart-pie', {prototype: ChartPieProto});
  //var chartPie = new ChartPie();
  //var chartPie = document.createElement('chart-pie');
</script>


<p>```
Let's walk through it piece by piece.</p>

<pre><code>&lt;template id="chart-pie"&gt;
  &lt;canvas class="myChart" width="200" height="200"&gt;&lt;/canvas&gt;
&lt;/template&gt;
</code></pre>

<p>On lines 1-3 we've shortened the <code>template</code> down so that it only contains our <code>canvas</code> tag. We'll use the Custom Element <code>createdCallback</code> to actually instantiate the chart in here.</p>

<br>


<pre><code>// thisDoc refers to the "importee", which is chart.html
var thisDoc = document.currentScript.ownerDocument;

// thatDoc refers to the "importer", which is index.html
var thatDoc = document;

var template = thisDoc.querySelector('#chart-pie');
</code></pre>

<p>Lines 6-12 should look familar from the last example. We're storing our two documents in variables and querying for the template tag.</p>

<br>


<pre><code>var ChartPieProto = Object.create(HTMLElement.prototype);
</code></pre>

<p>On line 15 we define the prototype for our Custom Element called <code>ChartPieProto</code>. This prototype extends the <code>HTMLElement</code> prototype which is a requirement for creating a new element.</p>

<br>


<pre><code>ChartPieProto.createdCallback = function() {
  ...
};
</code></pre>

<p>On line 20 we see the first lifecycle callback, <code>createdCallback</code>. The <code>createdCallback</code> is run every time the parser hits a new instance of our tag. Therefore we can use it as a kind of Constructor to kickoff the creation of our chart. We'll want to create a new chart instance for each tag so all of our Chart.js code has been moved inside of this callback.</p>

<br>


<pre><code>var root = this.createShadowRoot();
var clone = template.content.cloneNode(true);
</code></pre>

<p>On lines 22-23 we create a <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/">Shadow DOM</a> to hold the markup for our chart.</p>

<br>


<pre><code>var data = [
  {
    value: 30,
    color:"#F38630"
  },
  {
    value : 50,
    color : "#E0E4CC"
  },
  {
    value : 100,
    color : "#69D2E7"
  }
];

//Get the context of the canvas element we want to select
var ctx = clone.querySelector('.myChart').getContext('2d');
var myNewChart = new Chart(ctx).Pie(data);
</code></pre>

<p>Lines 26-43 should look familiar. It's the same Chart.js code from before except now we use <code>querySelector</code> to find the contents of the template clone and we're using a class for <code>myChart</code> instead of an id.</p>

<br>


<pre><code>root.appendChild(clone);
</code></pre>

<p>On line 46 we add the new content to our Shadow DOM.</p>

<br>


<pre><code>var ChartPie = document.register('chart-pie', {prototype: ChartPieProto});
</code></pre>

<p>Line 49 is where we actually register our Custom Element and assign it to the name <code>chart-pie</code>. From here you can either place a <code>&lt;chart-pie&gt;&lt;/chart-pie&gt;</code> tag somewhere on your page, or use JavaScript to instantiate an instance and add it to the <code>document</code>. This is demonstrated in the comments on lines 50-51. If you refer back to our <code>index.html</code> example we just use the <code>&lt;chart-pie&gt;</code> tag.</p>

<p>```html index.html
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Imports with Custom Elements&lt;/title&gt;
&lt;script src="http://robdodson.me/lib/chart.min.js"&gt;&lt;/script&gt;
&lt;link rel="import" href="http://robdodson.me/imports/chart.html"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;h1&gt;Quarterly Pokemon Sales&lt;/h1&gt;
&lt;chart-pie&gt;&lt;/chart-pie&gt;
&lt;chart-pie&gt;&lt;/chart-pie&gt;
&lt;chart-pie&gt;&lt;/chart-pie&gt;
</code></pre>

<p>  </body>
</html>
```
Which produces this:</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/imports-custom-elements.jpg" title="'Imports with Custom Elements'" ></p>

<h2>Conclusion</h2>

<p>If you've made it this far congrats and thanks for hanging in there! I know that last section was a little crazy but stop for a moment and think about what we just did.</p>

<p>By using an HTML Import we were able to pull in a document which added a new tag to our application. Imagine if <em>all</em> of Chart.js was written in this manner. There would be no need for us to write any glue code to generate a chart ever again. Instead we could manipulate the attributes of a <code>&lt;chart-pie&gt;</code> tag using something like Angular or any other front-end framework. That would allow us to focus only on the code that matters to our application and leave all that other boilerplate tucked away inside of Custom Elements.</p>

<p>As a matter of fact the Polymer folks have already started doing this. Checkout the <a href="https://github.com/Polymer/more-elements">more-elements project on GitHub</a> which includes proof of concept wrappers for a number of libraries including Chart.js. Thanks to Scott Miles on <a href="https://groups.google.com/forum/#!forum/polymer-dev">the Polymer Google Group</a> for pointing that out to me :)</p>

<p>Over the next few months I'll be blogging exclusively about this topic because I think it's really interesting so check back later for more!</p>

<p>Till then make sure to <a href="http://twitter.com/rob_dodson">hit me up on Twitter</a> if you have any questions or leave a note in the comments. Thanks!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML5 Template Tag: Introduction]]></title>
    <link href="http://robdodson.me/blog/2013/03/16/html5-template-tag-introduction/"/>
    <updated>2013-03-16T09:51:00-07:00</updated>
    <id>http://robdodson.me/blog/2013/03/16/html5-template-tag-introduction</id>
    <content type="html"><![CDATA[<p>If you've been following the Google Chrome release announcements you may have noticed some interesting terms popping up as of late. Phrases like "Shadow DOM", "Custom Elements" and "Template". These are all part of a new standard referred to as Web Components and the latest versions of Chrome are starting to implement them. Basically a Web Component is an encapsulated bit of markup, styles and script that allow you to reuse widgets across your page without worrying about accidental collisions. For a practical example consider Twitter Bootstrap and its myriad of buttons, dropdowns and badges. Bootstrap comes with <em>a lot</em> of CSS which means, right out of the gate, there are a ton of class names which you probably shouldn't use for your own elements. Want to define a class of <code>.container</code>? Too bad, Bootstrap already uses that name. Want to upgrade Bootstrap in a few months? OK, but you need to double check that none of their new classes conflict with any of yours. Kind of a pain, right? Wouldn't it be awesome if you could use all the little widgets from Bootstrap and not worry at all about possible collisions? Well, that's what Web Components are trying to solve and so today I want to look at one part of the Web Components standard: The Template Tag.</p>

<!--more-->


<h2>Feature Detection</h2>

<p>The &lt;template&gt; tag is currently only supported in Chrome 26 so you'll need to either run these examples in Chrome Canary or (if it's the future) a version of Chrome/FF/Whatever that supports &lt;template&gt;. Here's a little feature dection script I stole from the <a href="http://www.html5rocks.com/en/tutorials/webcomponents/template/">HTML5Rocks article</a> on <code>&lt;template&gt;</code>.</p>

<p>``` html</p>

<h3 class="template-detection">Does your browser support &lt;template&gt;: </h3>




<script>
  function supportsTemplate() {
    return 'content' in document.createElement('template');
  }

  $('.template-detection').append(supportsTemplate().toString().toUpperCase());
</script>


<p>```</p>

<h3 class="template-detection">Does your browser support &lt;template&gt;: </h3>




<script>
  function supportsTemplate() {
    return 'content' in document.createElement('template');
  }

  $('.template-detection').append(supportsTemplate().toString().toUpperCase());
</script>


<h2>Our first template</h2>

<p>There's a great <a href="http://www.html5rocks.com/en/tutorials/webcomponents/template/">HTML5Rocks article</a> on the subject of the <code>template</code> tag and I'm going to steal some of their examples.
Let's start by making a template for an image placeholder. We're going to use the <a href="http://hhhhold.com/">hhhhold</a> image service which will load in a random image from <a href="http://ffffound.com">ffffound.com</a>. The markup for our template will be pretty simple:</p>

<p>``` html
<template id="hhhhold-template">
  <img src="" alt="random hhhhold image">
  <h3 class="title"></h3>
</template></p>

<script>
  var template = document.querySelector('#hhhhold-template');
  template.content.querySelector('img').src = 'http://hhhhold.com/350x200';
  template.content.querySelector('.title').textContent = 'Random image from hhhhold.com'
  document.body.appendChild(template.content.cloneNode(true));
</script>


<p>```</p>

<p>Which would render something like this (remember to view in a browser that supports template):</p>

<div id="hhhold-container"></div>


<p><template id="hhhhold-template">
  <img src="" alt="random hhhhold image">
  <h3 class="title"></h3>
</template></p>

<script>
  var template = document.querySelector('#hhhhold-template');
  template.content.querySelector('img').src = 'http://hhhhold.com/350x200';
  template.content.querySelector('.title').textContent = 'Random image from hhhhold.com'
  document.querySelector('#hhhold-container').appendChild(template.content.cloneNode(true));
</script>


<p>If you've worked with client-side template libraries like underscore or handelbars the above should look familiar to you. Where underscore and handelbars take advantage of putting their templates inside of <code>&lt;script&gt;</code> tags and changing the <code>type</code> to something like <code>text/x-handlebars-template</code>, the <code>&lt;template&gt;</code> tag doesn't need to because it's actually part of the HTML5 spec. There are pros and cons to this approach.</p>

<h3>Pros</h3>

<ul>
<li>The content of the template is inert, scripts won't run, images won't load, audio won't play, etc. This means you can have <code>&lt;img&gt;</code> and <code>&lt;script&gt;</code> tags whose <code>src</code> attributes haven't been defined yet.</li>
<li>The child nodes of a template are hidden from selectors like <code>document.getElementById()</code> and <code>querySelector()</code> so you won't accidentally select them.</li>
<li>You can place the <code>&lt;template&gt;</code> pretty much anywhere on the page and grab it later.</li>
</ul>


<h3>Cons</h3>

<ul>
<li>You can't precompile the template into a JS function like you can with other libraries like handlebars.</li>
<li>You can't preload the assets referenced by a template (images, sounds, css, js).</li>
<li>You can't nest templates inside of one another and have it automagically work. If a template contains another template you'll have to activate the child, then activate the parent.</li>
<li>Very little browser support (only Chrome 26 at the time of this writing).</li>
</ul>


<p>Given that list of cons you might say "Well why would I ever bother with the <code>&lt;template&gt;</code> tag if something like handlebars gives me way more power?" That's a great question because by itself the <code>&lt;template&gt;</code> tag isn't so impressive. Its saving grace lies in the fact that it is intended to be used <em>along side</em> the Shadow DOM and Custom Elements to generate a Web Component.</p>

<p>Think back to the story about Bootstrap that I told at the beginning of this post. If all the markup for a Bootstrap button lived inside a template tag then we'd be one step closer to having a nice encapsulated widget. The next step would be to isolate the styles associated with the button. But I'll save that for tomorrow's post :)</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here</a>.</p>
]]></content>
  </entry>
  
</feed>
