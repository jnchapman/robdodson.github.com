<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Shadow DOM | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/shadow-dom/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2014-08-17T09:40:04-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Shadow DOM CSS Cheat Sheet]]></title>
    <link href="http://robdodson.me/blog/2014/04/10/shadow-dom-css-cheat-sheet/"/>
    <updated>2014-04-10T22:56:00-07:00</updated>
    <id>http://robdodson.me/blog/2014/04/10/shadow-dom-css-cheat-sheet</id>
    <content type="html"><![CDATA[<p>This guide is my attempt to track the progress of all the new CSS selectors which affect the Shadow DOM. I've written this from the perspective of someone who uses <a href="http://polymer-project.org">Polymer</a> so in a few places I point out polyfill features like <code>shim-shadowdom</code> and <code>polyfill-next-selector</code>. But the selectors themselves are all native and comply to <a href="http://drafts.csswg.org/css-scoping/">the current draft spec</a>.</p>

<!-- more -->


<p>Found a bug? <a href="https://github.com/robdodson/robdodson.github.com/blob/source/source/_posts/2014-04-10-shadow-dom-css-cheat-sheet.markdown">Submit a pull request!</a></p>

<p>Follow <a href="http://twitter.com/rob_dodson">@rob_dodson on the twitters</a></p>

<br>


<br>




<h2><a href="#shadow" id="shadow" class="no-underline">::shadow</a></h2>


<p>Selects shadow trees that are one level deep inside of an element. Will need to be combined with <code>shim-shadowdom</code> directive if used outside of a Polymer element in browsers that lack support for the native selector.</p>

<p><code>
x-foo::shadow h1 {
  color: red;
}
</code>
<a href="http://codepen.io/robdodson/pen/HeLEb">Try it on CodePen</a> | <a href="http://drafts.csswg.org/css-scoping/#selectordef-shadow">Read the Spec</a></p>

<table class="plain">
  <thead>
    <tr>
      <th>Support Type</th>
      <th>Chrome</th>
      <th>Firefox</th>
      <th>Internet Explorer</th>
      <th>Safari</th>
      <th>Opera</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="no-border">Polyfill</td>
      <td class="supported">Yes</td>
      <td class="supported">Yes</td>
      <td class="supported">10+</td>
      <td class="supported">6+</td>
      <td class="supported">Yes</td>
    </tr>
    <tr>
      <td>Native</td>
      <td class="supported">35</td>
      <td>?</td>
      <td>?</td>
      <td>?</td>
      <td>?</td>
    </tr>
  </tbody>
</table>




<br>


<br>




<h2><a href="#deep" id="deep" class="no-underline">/deep/</a></h2>


<p>Selects shadow trees that are N levels deep inside of an element. Will need to be combined with <code>shim-shadowdom</code> directive if used outside of a Polymer element in browsers that lack support for the native selector.</p>

<p><code>
x-foo /deep/ h1 {
  color: red;
}
</code>
<a href="http://codepen.io/robdodson/pen/wraDn/">Try it on CodePen</a> | <a href="http://drafts.csswg.org/css-scoping/#selectordef-deep">Read the Spec</a></p>

<table class="plain">
  <thead>
    <tr>
      <th>Support Type</th>
      <th>Chrome</th>
      <th>Firefox</th>
      <th>Internet Explorer</th>
      <th>Safari</th>
      <th>Opera</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="no-border">Polyfill</td>
      <td class="supported">Yes</td>
      <td class="supported">Yes</td>
      <td class="supported">10+</td>
      <td class="supported">6+</td>
      <td class="supported">Yes</td>
    </tr>
    <tr>
      <td>Native</td>
      <td class="supported">35</td>
      <td>?</td>
      <td>?</td>
      <td>?</td>
      <td>?</td>
    </tr>
  </tbody>
</table>




<br>


<br>




<h2><a href="#host" id="host" class="no-underline">:host</a></h2>


<p>Selects a shadow host element. May contain additional identifiers in parenthesis.</p>

<p><code>
:host(.fancy) {
  display: inline-block;
  background: purple;
}
</code>
<a href="http://codepen.io/robdodson/pen/rDuyJ/">Try it on CodePen</a> | <a href="http://drafts.csswg.org/css-scoping/#selectordef-host0">Read the Spec</a></p>

<table class="plain">
  <thead>
    <tr>
      <th>Support Type</th>
      <th>Chrome</th>
      <th>Firefox</th>
      <th>Internet Explorer</th>
      <th>Safari</th>
      <th>Opera</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="no-border">Polyfill</td>
      <td class="supported">Yes</td>
      <td class="supported">Yes</td>
      <td class="supported">10+</td>
      <td class="supported">6+</td>
      <td class="supported">Yes</td>
    </tr>
    <tr>
      <td>Native</td>
      <td class="supported">35</td>
      <td>?</td>
      <td>?</td>
      <td>?</td>
      <td>?</td>
    </tr>
  </tbody>
</table>




<br>


<br>




<h2><a href="#host-context" id="host-context" class="no-underline">:host-context</a></h2>


<p>Selects a shadow host based on a matching parent element.</p>

<p><code>
:host-context(.blocky) {
  display: block
  background: red;
}
</code>
<a href="http://codepen.io/robdodson/pen/ftpoG/">Try it on CodePen</a> | <a href="http://drafts.csswg.org/css-scoping/#selectordef-host-context">Read the Spec</a></p>

<table class="plain">
  <thead>
    <tr>
      <th>Support Type</th>
      <th>Chrome</th>
      <th>Firefox</th>
      <th>Internet Explorer</th>
      <th>Safari</th>
      <th>Opera</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="no-border">Polyfill</td>
      <td class="supported">Yes</td>
      <td class="supported">Yes</td>
      <td class="supported">10+</td>
      <td class="supported">6+</td>
      <td class="supported">Yes</td>
    </tr>
    <tr>
      <td>Native</td>
      <td class="supported">35</td>
      <td>?</td>
      <td>?</td>
      <td>?</td>
      <td>?</td>
    </tr>
  </tbody>
</table>




<br>


<br>




<h2><a href="#content" id="content" class="no-underline">::content</a></h2>


<p>Selects distributed nodes inside of an element. Needs to be paired with <code>polyfill-next-selector</code> for browsers that do not support the native selector.</p>

<p><code>
::content h1 {
  color: red;
}
</code>
<a href="http://codepen.io/robdodson/pen/FokEw/">Try it on CodePen</a> | <a href="http://drafts.csswg.org/css-scoping/#selectordef-content">Read the Spec</a></p>

<table class="plain">
  <thead>
    <tr>
      <th>Support Type</th>
      <th>Chrome</th>
      <th>Firefox</th>
      <th>Internet Explorer</th>
      <th>Safari</th>
      <th>Opera</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="no-border">Polyfill</td>
      <td class="supported">Yes</td>
      <td class="supported">Yes</td>
      <td class="supported">10+</td>
      <td class="supported">6+</td>
      <td class="supported">Yes</td>
    </tr>
    <tr>
      <td>Native</td>
      <td class="supported">35</td>
      <td>?</td>
      <td>?</td>
      <td>?</td>
      <td>?</td>
    </tr>
  </tbody>
</table>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[@font-face doesn't work in the Shadow DOM]]></title>
    <link href="http://robdodson.me/blog/2013/11/19/at-font-face-doesnt-work-in-shadow-dom/"/>
    <updated>2013-11-19T09:27:00-08:00</updated>
    <id>http://robdodson.me/blog/2013/11/19/at-font-face-doesnt-work-in-shadow-dom</id>
    <content type="html"><![CDATA[<p>I was building custom elements with Polymer the other day, and I thought it would be cool to include Font Awesome for some sweet icon goodness. Everything was going great, until I switched over to Canary to check my work.</p>

<!-- more -->


<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/polymer-fonts-busted.png" title="'Busted Polymer Fonts'" ></p>

<p>uh oh...</p>

<p>At first, I was pretty confused. Why was everything working fine in Chrome, but acting crazy in Canary? I did some digging and manged to turn up <a href="https://groups.google.com/d/msg/polymer-dev/UUwew3x82EU/m9x2qWPi9ZoJ">this thread</a> on the Polymer mailing list.</p>

<h2>The Fix</h2>

<p>I had a bit of an "aha moment" when I remembered that the current version of Chrome doesn't actually hide any styles in the Shadow DOM, so my <code>@font-face</code> rules were ending up in the global scope. Canary, on the other hand, is encapsulating those styles in a shadow boundary and falling prey to an apparent bug.</p>

<p>A simple workaround is to pull your <code>@font-face</code> rules out of the stylesheet for your element, and move them to the top of your import, like so:</p>

<p>```
&lt;style&gt;
  @font-face {</p>

<pre><code>font-family: 'FontAwesome';
src: url('../fonts/fontawesome-webfont.eot?v=4.0.3');
src: url('../fonts/fontawesome-webfont.eot?#iefix&amp;v=4.0.3') format('embedded-opentype'), url('../fonts/fontawesome-webfont.woff?v=4.0.3') format('woff'), url('../fonts/fontawesome-webfont.ttf?v=4.0.3') format('truetype'), url('../fonts/fontawesome-webfont.svg?v=4.0.3#fontawesomeregular') format('svg');
font-weight: normal;
font-style: normal;
</code></pre>

<p>  }
&lt;/style&gt;</p>

<p><polymer-element name="semantic-ui-icon" noscript>
  <template></p>

<pre><code>&lt;link rel="stylesheet" href="./icon.css"&gt;
&lt;content&gt;&lt;/content&gt;
</code></pre>

<p>  </template>
</polymer-element>
```</p>

<p>I found this approach <a href="http://www.polymer-project.org/docs/polymer/styling.html#making-styles-global">in the Polymer documentation</a>, so I'm hoping it's considered a best practice. You'll also need to do this if you're using <code>@-webkit-keyframes</code> rules.</p>

<p>I hope that clears things up for some of you who may have been stuck. I know it took me a couple days to come up with this solution, so I thought it best to go ahead and post about it :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Cat and the Hat CSS Selectors]]></title>
    <link href="http://robdodson.me/blog/2013/11/15/the-cat-and-the-hat-css-selectors/"/>
    <updated>2013-11-15T11:08:00-08:00</updated>
    <id>http://robdodson.me/blog/2013/11/15/the-cat-and-the-hat-css-selectors</id>
    <content type="html"><![CDATA[<p><em>03/18/2014: This post is now out of date. The cat and hat CSS selectors have been removed in favor of <a href="http://drafts.csswg.org/css-scoping/#shadow-pseudoelement"><code>::shadow</code></a> and <a href="http://drafts.csswg.org/css-scoping/#deep-combinator"><code>/deep/</code></a>. Take a look at <a href="http://drafts.csswg.org/css-scoping/">the CSS Scoping Draft Spec</a> for current selector status.</em></p>

<p>One of the trickier aspects of encapsulating Shadow DOM CSS is figuring out how much access the parent document should have. Initially it was thought that the Shadow DOM's author would decide which elements could be exposed for styling <a href="/blog/2013/08/29/shadow-dom-styles-cont-dot#parts">by using <code>part</code> attributes</a>, but it seems like that might be too limiting. The thinking now is that the shadow boundary should prevent <em>accidental</em> styling of the shadow DOM, but allow intentional styles. That's where the new "cat" and "hat" CSS selectors come in.</p>

<!-- more -->


<h2>Support <a href="#" id="support"></a></h2>

<p>In order to try the examples I suggest you use <a href="https://www.google.com/intl/en/chrome/browser/canary.html">Chrome Canary</a> v33 or greater.</p>

<p>Also make sure you've enabled <strong>Experimental Web Platform features</strong> in Chrome's <code>chrome://flags</code>.</p>

<h2>The Hat <a href="#" id="the-hat"></a></h2>

<p>The hat selector, a single caret ( ^ ), allows the parent document to pierce the <strong>upper shadow boundary</strong> and style elements that are one shadow root deep. If you have an element that only has one shadow root you can style pretty much anything inside of it using the hat.</p>

<p data-height="268" data-theme-id="0" data-slug-hash="EhIax" data-user="robdodson" data-default-tab="css" class='codepen'>See the Pen <a href='http://codepen.io/robdodson/pen/EhIax'>Shadow DOM "Hat" CSS selector</a> by Rob Dodson (<a href='http://codepen.io/robdodson'>@robdodson</a>) on <a href='http://codepen.io'>CodePen</a></p>


<script async src="http://robdodson.me//codepen.io/assets/embed/ei.js"></script>


<h2>The Cat <a href="#" id="the-cat"></a></h2>

<p>The cat, a double caret ( ^^ ) is much more powerful. It allows you to pierce every layer of the shadow DOM, so if you have shadow DOM within shadow DOM (a common occurrence when you nest custom elements) you can style all of them at once.</p>

<p data-height="315" data-theme-id="0" data-slug-hash="wFqJg" data-user="robdodson" data-default-tab="css" class='codepen'>See the Pen <a href='http://codepen.io/robdodson/pen/wFqJg'>Shadow DOM "Cat" CSS selector</a> by Rob Dodson (<a href='http://codepen.io/robdodson'>@robdodson</a>) on <a href='http://codepen.io'>CodePen</a></p>


<script async src="http://robdodson.me//codepen.io/assets/embed/ei.js"></script>


<h2>Styling Native Elements <a href="#" id="styling-native-elements"></a></h2>

<p><a href="https://twitter.com/Volker_E/status/401202275009310722">@Volker_E asked</a> if the cat and hat selectors could be used to style the shadow DOM of native elements like <code>&lt;video&gt;</code>. As it turns out that <em>does</em> work, which is pretty cool.</p>

<p data-height="268" data-theme-id="0" data-slug-hash="iaJHd" data-user="robdodson" data-default-tab="css" class='codepen'>See the Pen <a href='http://codepen.io/robdodson/pen/iaJHd'>Shadow DOM "Cat" and "Hat" CSS selectors</a> by Rob Dodson (<a href='http://codepen.io/robdodson'>@robdodson</a>) on <a href='http://codepen.io'>CodePen</a></p>


<script async src="http://robdodson.me//codepen.io/assets/embed/ei.js"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating a Markdown Tag with Polymer]]></title>
    <link href="http://robdodson.me/blog/2013/10/02/creating-a-markdown-tag-with-polymer/"/>
    <updated>2013-10-02T08:05:00-07:00</updated>
    <id>http://robdodson.me/blog/2013/10/02/creating-a-markdown-tag-with-polymer</id>
    <content type="html"><![CDATA[<p>Ah Markdown... Such an amazing tool. I honestly would not be writing this blog post if Markdown did not exist. I tried many times to get in to blogging but I always found the writing experience, whether it be in a GUI or WordPress' HTML mode, too limiting. Markdown changed all of that for me and I think it's high time we make it a full fledged member of our developer toolbox.</p>

<p>So today I'm going to show you how to build a Markdown tag using <a href="http://www.polymer-project.org/">Polymer, a Web Components framework from Google.</a></p>

<!-- more -->


<h2>Github</h2>

<p><a href="https://github.com/robdodson/mark-down">If you'd like to follow along you can grab the code from Github.</a></p>

<h2>The Setup</h2>

<p>First things first, we need to download the latest version of Polymer. I like to do this with <a href="http://bower.io">bower</a> and I would encourage you to do so as well. Although it hasn't been discussed much, I think bower is going to be as important to web components as npm and the node_modules folder is to Node.js. When developers can assume the location and version of a dependency then they're able to remove extra work from the consumer's plate. But that's a discussion for another day! For now let's just run</p>

<p><code>
bower init
</code></p>

<p>to create our <code>bower.json</code> file.</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/bower-init.jpg" title="'bower init is kinda awesome'" ></p>

<p>And we'll want to install our Polymer and Markdown dependencies so</p>

<p><code>
bower install polymer marked --save
</code></p>

<p>Lastly we'll setup a test page for our element. I'm going to assume that the element lives in a folder called (creatively) <code>elements</code> so we'll import from there.</p>

<p>``` html
&lt;!DOCTYPE html>
<html lang="en">
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;Markdown Polymer Element&lt;/title&gt;
&lt;!-- Import our polymer element --&gt;
&lt;link rel="import" href="elements/mark-down.html"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;!-- Test our awesome new tag --&gt;
&lt;mark-down&gt;&lt;/mark-down&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<h2>The Element</h2>

<p>We'll start with a very basic skeleton in our <code>elements/mark-down.html</code> file.</p>

<p>``` html
<link rel="import" href="../polymer/polymer.html">
<polymer-element name="mark-down">
  <template></p>

<pre><code>&lt;div id="markdown"&gt;&lt;/div&gt;
</code></pre>

<p>  </template>
  <script></p>

<pre><code>Polymer("mark-down");
</code></pre>

<p>  </script>
</polymer-element>
```</p>

<p>Let's walk through this a bit.</p>

<p><code>html
&lt;polymer-element name="mark-down"&gt;
</code>
This line tells Polymer that we'd like to define a new element and its tag name should be <code>mark-down</code>.</p>

<p><code>html
&lt;template&gt;
  &lt;div id="markdown"&gt;&lt;/div&gt;
&lt;/template&gt;
</code>
This is our template which Polymer will convert to <a href="/blog/2013/08/26/shadow-dom-introduction/">Shadow DOM.</a> All of the Markdown that we write inside of the <code>&lt;mark-down&gt;</code> tag will be parsed and end up here.</p>

<p>``` html</p>

<script>
  Polymer("mark-down");
</script>


<p>```
Finally, we call the Polymer constructor and pass it the name of our element. This makes our new tag available so we can start using it in the document. But first we'll need to parse our Markdown into HTML!</p>

<h2>Markdown</h2>

<p>We'll use Polymer's <a href="http://www.polymer-project.org/docs/polymer/polymer.html#lifecyclemethods"><code>ready</code> callback</a> to grab the <code>textContent</code> of our tag and convert it all to Markdown. To define behaviors for our element we'll pass a prototype object as the second argument to the Polymer constructor.</p>

<p>``` js
Polymer("mark-down", {
  ready: function() {</p>

<pre><code>var content = this.trim(this.textContent);
var parsed = markdown.toHTML(content);
this.$.markdown.innerHTML = parsed;
</code></pre>

<p>  },
  // Remove excess white space
  trim: function() { ... }
});
```</p>

<p>The first thing we do is to grab everything inside of the <code>&lt;mark-down&gt;</code> tag and remove any extra white space. Here I'm using a trim method that I borrowed from <a href="https://github.com/ryanseddon/markdown-component">Ryan Seddon's Markdown element.</a> Big thanks to Ryan :D</p>

<p><code>js
ready: function() {
  var content = this.trim(this.textContent);
  ...
},
</code></p>

<p>Next we convert the content into Markdown using the <code>toHTML</code> method of our Markdown library. Then we take this new, more presentational markup, and add it to the <code>#markdown</code> div inside of our <code>template</code>.</p>

<p><code>js
ready: function() {
  ...
  var parsed = markdown.toHTML(content);
  this.$.markdown.innerHTML = parsed;
}
</code></p>

<h3>Node Finding</h3>

<p>You might notice the funny use of <code>$</code> and think I'm doing something clever with jQuery. What's actually happening is that Polymer creates a map of any element inside of our template with an <code>id</code>. It then stores this map in a <code>$</code> property. So if you're using ids you can quickly access elements with the use of <code>this.$.someId</code>. In the Polymer docs this is referred to as <a href="http://www.polymer-project.org/getting-started.html#automatic-node-finding">automatic node finding.</a></p>

<p><em>But aren't ids an anti-pattern?</em></p>

<p>Although the traditional document model only allows for one id per page, the Shadow DOM creates a kind of clean slate where each element has its own id sandbox. This means we can use an id of <code>#markdown</code> in our element and not worry if the parent document also contains an element with id <code>#markdown</code>. Pretty nifty!</p>

<h2>Test</h2>

<p>The only thing left is for us to throw some Markdown into our tag to test it out.</p>

<p>``` html
<mark-down>
  # This is a heading
  ## This is a subheading</p>

<p>  Here is <strong>more</strong> <em>Markdown!</em></p>

<p>  <code>This is some codez</code></p>

<p>  This <a href="http://robdodson.me">is a link</a>
</mark-down>
```</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/markdown-example.jpg" title="'sweet sweet markdown!'" ></p>

<p>Piece O' Cake!</p>

<h2>Moar!</h2>

<p>There's a lot more that we could do, for instance, using something like <code>contenteditable</code> to allow us to toggle back and forth between the source and the rendered content. <a href="https://github.com/robdodson/mark-down">I've posted the code on Github</a> so fork it and go crazy.</p>

<p>Be sure to leave a comment if you want to share your experiments!</p>

<p>Till next time!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shadow DOM: JavaScript]]></title>
    <link href="http://robdodson.me/blog/2013/09/02/shadow-dom-javascript/"/>
    <updated>2013-09-02T20:46:00-07:00</updated>
    <id>http://robdodson.me/blog/2013/09/02/shadow-dom-javascript</id>
    <content type="html"><![CDATA[<p>We're getting to a point where we've covered most of what there is to know about <a href="/blog/2013/03/16/html5-template-tag-introduction/">templates</a>, <a href="/blog/2013/08/20/exploring-html-imports/">imports</a> and shadow DOM (<a href="/blog/2013/08/26/shadow-dom-introduction/">1</a>, <a href="/blog/2013/08/27/shadow-dom-the-basics/">2</a>, <a href="/blog/2013/08/28/shadow-dom-styles/">3</a>, <a href="/blog/2013/08/29/shadow-dom-styles-cont-dot/">4</a>). The end goal for all of these technologies is <strong>custom elements</strong>, but we're not <em>quite</em> there yet. I want you to understand the basics of working with JavaScript and the shadow DOM before diving head first into making your own elements. So in this post I'm going to explain some things to watch out for, in particular around how events work. With this knowledge under your belt you'll be in a good place to start creating your own custom elements.</p>

<p>Let's get crackin'!</p>

<!--more-->


<p><em>Before we get started I wanted to thank Eric Bidelman for his <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-301/">amazing article on advanced Shadow DOM</a>. Most of this article is my interpretation of his post and I'm only covering a subset of what he presented. Definitely go read <a href="http://www.html5rocks.com/en/tutorials/#webcomponents">everything on HTML5 Rocks that pertains to Web Components</a> when you get a chance.</em></p>

<h2>Support <a href="#" id="support"></a></h2>

<p>In order to try the examples I suggest you use <a href="https://www.google.com/intl/en/chrome/browser/canary.html">Chrome Canary</a> v35 or greater.</p>

<p>Also make sure you've enabled the following in Chrome's <code>about:flags</code>.</p>

<p>√ Experimental Web Platform features<br>
√ Experimental JavaScript<br></p>

<h2>Codez! <a href="#" id="codez"></a></h2>

<p>I've created a sketchbook for this post and future Web Components related stuff. <a href="https://github.com/robdodson/webcomponents-sketchbook">You can grab the sketchbook on GitHub.</a> For each of the examples that I cover I'll link to the sketch so you can quickly try things out.</p>

<h2>JavaScript Scope <a href="#" id="javascript-scope"></a></h2>

<h3>Sketch 13: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/13-javascript-scope">javascript-scope</a></h3>

<p>Remember when I spent all of that time <a href="/blog/2013/08/28/shadow-dom-styles/">explaining how Shadow DOM CSS was encapsulated and protected from the parent document</a> and how awesome that all was? You might also think that JavaScript works the same way—<em>I did at first</em>—but that's actually not the case. With a few exceptions, which I'll discuss later, JavaScript in the Shadow DOM works pretty much exactly as it always has. That means all the best practices you've learned over the years still apply.</p>

<p>Here's an example of what I'm talking about.</p>

<p>```html
<body>
  <div id="host"></div>
  <template></p>

<pre><code>&lt;h1&gt;Hello World!&lt;/h1&gt;
&lt;script&gt;
var foo = 'bar';
&lt;/script&gt;
</code></pre>

<p>  </template>
  <script></p>

<pre><code>var host = document.querySelector('#host');
var root = host.createShadowRoot();
var template = document.querySelector('template');
root.appendChild(document.importNode(template.content, true));
console.log('window.foo = ' + window.foo);
</code></pre>

<p>  </script>
</body>
```
<img class="center" src="http://robdodson.s3.amazonaws.com/images/shadow-dom-js1.jpg" title="'Shadow DOM global variable'" ></p>

<p>Even though we're using a template tag and our script block is inside the Shadow DOM, the <code>foo</code> variable still attaches itself to the <code>window</code>. There's no special magic to keep it out of the global scope. Instead we need to rely on our trusty friend, <a href="http://en.wikipedia.org/wiki/Immediately-invoked_function_expression">the IIFE</a>, to make sure everything stays protected.</p>

<p>```html
<template>
  <h1>Hello World!</h1>
  <script>
  (function () {</p>

<pre><code>var foo = 'bar';
</code></pre>

<p>  }());
  </script>
</template>
```</p>

<p><img class="center" src="http://robdodson.s3.amazonaws.com/images/shadow-dom-js2.jpg" title="'Shadow DOM IIFE'" ></p>

<p>That's more like it!</p>

<h2>Event Retargeting <a href="#" id="event-retargeting"></a></h2>

<p>One place where Shadow DOM JavaScript really differs from conventional script is in regard to event dispatching. The thing to remember is that <strong>events originating from nodes inside of the shadow DOM are retargeted so they appear to come from the shadow host.</strong></p>

<p>I know that doesn't really sink in without an example so try this out.</p>

<h3>Sketch 14: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/14-event-retargeting-shadow-nodes">event-retargeting-shadow-nodes</a></h3>

<p>```html
<body>
  <input id="normal-text" type="text" value="I'm normal text"></p>

<p>  <div id="host"></div></p>

<p>  <template></p>

<pre><code>&lt;input id="shadow-text" type="text" value="I'm shadow text"&gt;
</code></pre>

<p>  </template></p>

<p>  <script></p>

<pre><code>var host = document.querySelector('#host');
var root = host.createShadowRoot();
var template = document.querySelector('template');
root.appendChild(document.importNode(template.content, true));

document.addEventListener('click', function(e) {
  console.log(e.target.id + ' clicked!');
});
</code></pre>

<p>  </script>
</body>
```
<a class="jsbin-embed" href="http://jsbin.com/IpaNAMi/3/embed?console,output">Shadow DOM Event Retargeting</a><script src="http://static.jsbin.com/js/embed.js"></script></p>

<p>Click on each of the above text fields and checkout what the console outputs. When you click on the "normal text" field it logs the <code>id</code> of that input. However, when you click on the "shadow text" field it logs the <code>id</code> of the host element (which is just <code>#host</code>). This is because <strong>events coming from shadow nodes have to be retargeted otherwise they would break encapsulation.</strong> If the event target continued to point at <code>#shadow-text</code> then anyone could dig around inside of our Shadow DOM and start messing things up.</p>

<h3>Distributed Nodes</h3>

<p>If you recall from the last post we talked about <a href="/blog/2013/08/29/shadow-dom-styles-cont-dot#distributed-nodes">distributed nodes</a>, which are bits of content taken from the shadow host and projected into the Shadow DOM. You might think that since these nodes appear in the Shadow DOM that their events would be retargeted as well. But that's not the case.</p>

<p>Heres' another example to demonstrate.</p>

<h3>Sketch 15: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/15-event-retargeting-distributed-nodes">event-retargeting-distributed-nodes</a></h3>

<p>```html
<body>
  <input id="normal-text" type="text" value="I'm normal text"></p>

<p>  <div id="host"></p>

<pre><code>&lt;input id="distributed-text" type="text" value="I'm distributed text"&gt;
</code></pre>

<p>  </div></p>

<p>  <template></p>

<pre><code>&lt;div&gt;
  &lt;input id="shadow-text" type="text" value="I'm shadow text"&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;content&gt;&lt;/content&gt;
&lt;/div&gt;
</code></pre>

<p>  </template></p>

<p>  <script></p>

<pre><code>var host = document.querySelector('#host');
var root = host.createShadowRoot();
var template = document.querySelector('template');
root.appendChild(document.importNode(template.content, true));

document.addEventListener('click', function(e) {
  console.log(e.target.id + ' clicked!');
});
</code></pre>

<p>  </script>
</body>
```
<a class="jsbin-embed" href="http://jsbin.com/UyIRUta/2/embed?console,output">Shadow DOM Event Retargeting</a><script src="http://static.jsbin.com/js/embed.js"></script></p>

<p>Like before, as you click on each input field you'll see the id of the event's target element. Clicking on the "distributed text" field shows that its event target remains intact. That's because a distributed node comes from the parent document, so the user already has access to it. There's no need to retarget its events and, in fact, you probably wouldn't want to. If a user gives you a button to style with Shadow DOM they're going to want to be able to listen to click events on it at some point.</p>

<h2>Blocked Events <a href="#" id="blocked-events"></a></h2>

<h3>Sketch 16: <a href="https://github.com/robdodson/webcomponents-sketchbook/tree/master/shadow-dom/16-stopped-events">stopped-events</a></h3>

<p>In some instances events are killed off rather than retargeted. The following events are always stopped at the root node and cannot be observed by the parent document:</p>

<ul>
<li><code>abort</code></li>
<li><code>error</code></li>
<li><code>select</code></li>
<li><code>change</code></li>
<li><code>load</code></li>
<li><code>reset</code></li>
<li><code>resize</code></li>
<li><code>scroll</code></li>
<li><code>selectstart</code></li>
</ul>


<p>Here's an example to demonstrate what I mean.</p>

<p>```html
<body>
  <input id="normal-text" type="text" value="I'm normal text"></p>

<p>  <div id="host"></p>

<pre><code>&lt;input id="distributed-text" type="text" value="I'm distributed text"&gt;
</code></pre>

<p>  </div></p>

<p>  <template></p>

<pre><code>&lt;div&gt;
  &lt;content&gt;&lt;/content&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;input id="shadow-text" type="text" value="I'm shadow text"&gt;
&lt;/div&gt;
</code></pre>

<p>  </template>
  <script></p>

<pre><code>var host = document.querySelector('#host');
var root = host.createShadowRoot();
var template = document.querySelector('template');
root.appendChild(document.importNode(template.content, true));

document.addEventListener('select', function(e) {
  console.log(e.target.id + ' text selected!');
});
</code></pre>

<p>  </script>
</body>
```
<a class="jsbin-embed" href="http://jsbin.com/oLuZePo/2/embed?console,output">Shadow DOM Stopped Events</a><script src="http://static.jsbin.com/js/embed.js"></script></p>

<p>Here I'm listening for <code>select</code> events which are triggered whenever you click and drag to highlight some text. If you try highlighting the text inside of the "normal text" input it should log <code>normal-text text selected!</code>. The "distributed text" input reacts in a similar fashion. But if you try to highlight the text inside of the "shadow text" input, nothing appears in the console. The event has been killed at the shadow root so it can't bubble up to the document where our event listener lives. Keep this in mind if you think you need to use any of the above listed events in your Shadow DOM.</p>

<h2>Conclusion <a href="#" id="conclusion"></a></h2>

<p>So nothing <em>too</em> bad I hope. A few gotchas with JavaScript events but otherwise things work pretty much like what we're accustomed to. If you read through the previous posts then you're ready to move on to Custom Elements and <a href="http://www.polymer-project.org/">Polymer</a>! Refer back to these articles if you feel lost and as always be sure to <a href="http://twitter.com/rob_dodson">hit me up on twitter</a> or leave a comment if you have any questions. Thanks!</p>
]]></content>
  </entry>
  
</feed>
